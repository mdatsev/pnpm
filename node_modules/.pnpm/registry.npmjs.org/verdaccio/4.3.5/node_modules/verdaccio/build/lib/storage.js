"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = _interopRequireDefault(require("lodash"));

var _assert = _interopRequireDefault(require("assert"));

var _async = _interopRequireDefault(require("async"));

var _stream = _interopRequireDefault(require("stream"));

var _upStorage = _interopRequireDefault(require("./up-storage"));

var _search = _interopRequireDefault(require("./search"));

var _constants = require("./constants");

var _localStorage = _interopRequireDefault(require("./local-storage"));

var _streams = require("@verdaccio/streams");

var _storageUtils = require("./storage-utils");

var _uplinkUtil = require("./uplink-util");

var _metadataUtils = require("./metadata-utils");

var _utils = require("./utils");

var _configUtils = require("./config-utils");

var _logger = require("../lib/logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Storage {
  constructor(config) {
    _defineProperty(this, "localStorage", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "logger", void 0);

    _defineProperty(this, "uplinks", void 0);

    _defineProperty(this, "filters", void 0);

    this.config = config;
    this.uplinks = (0, _uplinkUtil.setupUpLinks)(config);
    this.logger = _logger.logger.child();
    this.filters = []; // @ts-ignore

    this.localStorage = null;
  }

  init(config, filters = []) {
    this.filters = filters;
    this.localStorage = new _localStorage.default(this.config, _logger.logger);
    return this.localStorage.getSecret(config);
  }
  /**
   *  Add a {name} package to a system
   Function checks if package with the same name is available from uplinks.
   If it isn't, we create package locally
   Used storages: local (write) && uplinks
   */


  async addPackage(name, metadata, callback) {
    try {
      await (0, _storageUtils.checkPackageLocal)(name, this.localStorage);
      await (0, _storageUtils.checkPackageRemote)(name, this._isAllowPublishOffline(), this._syncUplinksMetadata.bind(this));
      await (0, _storageUtils.publishPackage)(name, metadata, this.localStorage);
      callback();
    } catch (err) {
      callback(err);
    }
  }

  _isAllowPublishOffline() {
    return typeof this.config.publish !== 'undefined' && _lodash.default.isBoolean(this.config.publish.allow_offline) && this.config.publish.allow_offline;
  }

  readTokens(filter) {
    return this.localStorage.readTokens(filter);
  }

  saveToken(token) {
    return this.localStorage.saveToken(token);
  }

  deleteToken(user, tokenKey) {
    return this.localStorage.deleteToken(user, tokenKey);
  }
  /**
   * Add a new version of package {name} to a system
   Used storages: local (write)
   */


  addVersion(name, version, metadata, tag, callback) {
    this.localStorage.addVersion(name, version, metadata, tag, callback);
  }
  /**
   * Tags a package version with a provided tag
   Used storages: local (write)
   */


  mergeTags(name, tagHash, callback) {
    this.localStorage.mergeTags(name, tagHash, callback);
  }
  /**
   * Change an existing package (i.e. unpublish one version)
   Function changes a package info from local storage and all uplinks with write access./
   Used storages: local (write)
   */


  changePackage(name, metadata, revision, callback) {
    this.localStorage.changePackage(name, metadata, revision, callback);
  }
  /**
   * Remove a package from a system
   Function removes a package from local storage
   Used storages: local (write)
   */


  removePackage(name, callback) {
    this.localStorage.removePackage(name, callback); // update the indexer

    _search.default.remove(name);
  }
  /**
   Remove a tarball from a system
   Function removes a tarball from local storage.
   Tarball in question should not be linked to in any existing
   versions, i.e. package version should be unpublished first.
   Used storage: local (write)
   */


  removeTarball(name, filename, revision, callback) {
    this.localStorage.removeTarball(name, filename, revision, callback);
  }
  /**
   * Upload a tarball for {name} package
   Function is synchronous and returns a WritableStream
   Used storages: local (write)
   */


  addTarball(name, filename) {
    return this.localStorage.addTarball(name, filename);
  }
  /**
   Get a tarball from a storage for {name} package
   Function is synchronous and returns a ReadableStream
   Function tries to read tarball locally, if it fails then it reads package
   information in order to figure out where we can get this tarball from
   Used storages: local || uplink (just one)
   */


  getTarball(name, filename) {
    const readStream = new _streams.ReadTarball({});

    readStream.abort = function () {};

    const self = this; // if someone requesting tarball, it means that we should already have some
    // information about it, so fetching package info is unnecessary
    // trying local first
    // flow: should be IReadTarball

    let localStream = self.localStorage.getTarball(name, filename);
    let isOpen = false;
    localStream.on('error', err => {
      if (isOpen || err.status !== _constants.HTTP_STATUS.NOT_FOUND) {
        return readStream.emit('error', err);
      } // local reported 404


      const err404 = err;
      localStream.abort();
      localStream = null; // we force for garbage collector

      self.localStorage.getPackageMetadata(name, (err, info) => {
        if (_lodash.default.isNil(err) && info._distfiles && _lodash.default.isNil(info._distfiles[filename]) === false) {
          // information about this file exists locally
          serveFile(info._distfiles[filename]);
        } else {
          // we know nothing about this file, trying to get information elsewhere
          self._syncUplinksMetadata(name, info, {}, (err, info) => {
            if (_lodash.default.isNil(err) === false) {
              return readStream.emit('error', err);
            }

            if (_lodash.default.isNil(info._distfiles) || _lodash.default.isNil(info._distfiles[filename])) {
              return readStream.emit('error', err404);
            }

            serveFile(info._distfiles[filename]);
          });
        }
      });
    });
    localStream.on('content-length', function (v) {
      readStream.emit('content-length', v);
    });
    localStream.on('open', function () {
      isOpen = true;
      localStream.pipe(readStream);
    });
    return readStream;
    /**
     * Fetch and cache local/remote packages.
     * @param {Object} file define the package shape
     */

    function serveFile(file) {
      let uplink = null;

      for (const uplinkId in self.uplinks) {
        if (self.uplinks[uplinkId].isUplinkValid(file.url)) {
          uplink = self.uplinks[uplinkId];
        }
      }

      if (uplink == null) {
        uplink = new _upStorage.default({
          url: file.url,
          cache: true,
          _autogenerated: true
        }, self.config);
      }

      let savestream = null;

      if (uplink.config.cache) {
        savestream = self.localStorage.addTarball(name, filename);
      }

      let on_open = function () {
        // prevent it from being called twice
        on_open = function () {};

        const rstream2 = uplink.fetchTarball(file.url);
        rstream2.on('error', function (err) {
          if (savestream) {
            savestream.abort();
          }

          savestream = null;
          readStream.emit('error', err);
        });
        rstream2.on('end', function () {
          if (savestream) {
            savestream.done();
          }
        });
        rstream2.on('content-length', function (v) {
          readStream.emit('content-length', v);

          if (savestream) {
            savestream.emit('content-length', v);
          }
        });
        rstream2.pipe(readStream);

        if (savestream) {
          rstream2.pipe(savestream);
        }
      };

      if (savestream) {
        savestream.on('open', function () {
          on_open();
        });
        savestream.on('error', function (err) {
          self.logger.warn({
            err: err,
            fileName: file
          }, 'error saving file @{fileName}: @{err.message}\n@{err.stack}');

          if (savestream) {
            savestream.abort();
          }

          savestream = null;
          on_open();
        });
      } else {
        on_open();
      }
    }
  }
  /**
   Retrieve a package metadata for {name} package
   Function invokes localStorage.getPackage and uplink.get_package for every
   uplink with proxy_access rights against {name} and combines results
   into one json object
   Used storages: local && uplink (proxy_access)
    * @param {object} options
   * @property {string} options.name Package Name
   * @property {object}  options.req Express `req` object
   * @property {boolean} options.keepUpLinkData keep up link info in package meta, last update, etc.
   * @property {function} options.callback Callback for receive data
   */


  getPackage(options) {
    this.localStorage.getPackageMetadata(options.name, (err, data) => {
      if (err && (!err.status || err.status >= _constants.HTTP_STATUS.INTERNAL_ERROR)) {
        // report internal errors right away
        return options.callback(err);
      }

      this._syncUplinksMetadata(options.name, data, {
        req: options.req,
        uplinksLook: options.uplinksLook
      }, function getPackageSynUpLinksCallback(err, result, uplinkErrors) {
        if (err) {
          return options.callback(err);
        }

        (0, _utils.normalizeDistTags)((0, _storageUtils.cleanUpLinksRef)(options.keepUpLinkData, result)); // npm can throw if this field doesn't exist

        result._attachments = {};
        options.callback(null, result, uplinkErrors);
      });
    });
  }
  /**
   Retrieve remote and local packages more recent than {startkey}
   Function streams all packages from all uplinks first, and then
   local packages.
   Note that local packages could override registry ones just because
   they appear in JSON last. That's a trade-off we make to avoid
   memory issues.
   Used storages: local && uplink (proxy_access)
   * @param {*} startkey
   * @param {*} options
   * @return {Stream}
   */


  search(startkey, options) {
    const self = this; // stream to write a tarball

    const stream = new _stream.default.PassThrough({
      objectMode: true
    });

    _async.default.eachSeries(Object.keys(this.uplinks), function (up_name, cb) {
      // shortcut: if `local=1` is supplied, don't call uplinks
      if (options.req.query.local !== undefined) {
        return cb();
      } // search by keyword for each uplink


      const lstream = self.uplinks[up_name].search(options); // join streams

      lstream.pipe(stream, {
        end: false
      });
      lstream.on('error', function (err) {
        self.logger.error({
          err: err
        }, 'uplink error: @{err.message}');
        cb();

        cb = function () {};
      });
      lstream.on('end', function () {
        cb();

        cb = function () {};
      });

      stream.abort = function () {
        if (lstream.abort) {
          lstream.abort();
        }

        cb();

        cb = function () {};
      };
    }, // executed after all series
    function () {
      // attach a local search results
      const lstream = self.localStorage.search(startkey, options);

      stream.abort = function () {
        lstream.abort();
      };

      lstream.pipe(stream, {
        end: true
      });
      lstream.on('error', function (err) {
        self.logger.error({
          err: err
        }, 'search error: @{err.message}');
        stream.end();
      });
    });

    return stream;
  }
  /**
   * Retrieve only private local packages
   * @param {*} callback
   */


  getLocalDatabase(callback) {
    const self = this;
    this.localStorage.storagePlugin.get((err, locals) => {
      if (err) {
        callback(err);
      }

      const packages = [];

      const getPackage = function (itemPkg) {
        self.localStorage.getPackageMetadata(locals[itemPkg], function (err, pkgMetadata) {
          if (_lodash.default.isNil(err)) {
            const latest = pkgMetadata[_constants.DIST_TAGS].latest;

            if (latest && pkgMetadata.versions[latest]) {
              const version = pkgMetadata.versions[latest];
              const timeList = pkgMetadata.time;
              const time = timeList[latest]; // @ts-ignore

              version.time = time; // Add for stars api
              // @ts-ignore

              version.users = pkgMetadata.users;
              packages.push(version);
            } else {
              self.logger.warn({
                package: locals[itemPkg]
              }, 'package @{package} does not have a "latest" tag?');
            }
          }

          if (itemPkg >= locals.length - 1) {
            callback(null, packages);
          } else {
            getPackage(itemPkg + 1);
          }
        });
      };

      if (locals.length) {
        getPackage(0);
      } else {
        callback(null, []);
      }
    });
  }
  /**
   * Function fetches package metadata from uplinks and synchronizes it with local data
   if package is available locally, it MUST be provided in pkginfo
   returns callback(err, result, uplink_errors)
   */


  _syncUplinksMetadata(name, packageInfo, options, callback) {
    let found = true;
    const self = this;
    const upLinks = [];
    const hasToLookIntoUplinks = _lodash.default.isNil(options.uplinksLook) || options.uplinksLook;

    if (!packageInfo) {
      found = false;
      packageInfo = (0, _storageUtils.generatePackageTemplate)(name);
    }

    for (const uplink in this.uplinks) {
      if ((0, _configUtils.hasProxyTo)(name, uplink, this.config.packages) && hasToLookIntoUplinks) {
        upLinks.push(this.uplinks[uplink]);
      }
    }

    _async.default.map(upLinks, (upLink, cb) => {
      const _options = Object.assign({}, options);

      const upLinkMeta = packageInfo._uplinks[upLink.upname];

      if ((0, _utils.isObject)(upLinkMeta)) {
        const fetched = upLinkMeta.fetched;

        if (fetched && Date.now() - fetched < upLink.maxage) {
          return cb();
        }

        _options.etag = upLinkMeta.etag;
      }

      upLink.getRemoteMetadata(name, _options, (err, upLinkResponse, eTag) => {
        if (err && err.remoteStatus === 304) {
          upLinkMeta.fetched = Date.now();
        }

        if (err || !upLinkResponse) {
          return cb(null, [err || _utils.ErrorCode.getInternalError('no data')]);
        }

        try {
          (0, _utils.validateMetadata)(upLinkResponse, name);
        } catch (err) {
          self.logger.error({
            sub: 'out',
            err: err
          }, 'package.json validating error @{!err.message}\n@{err.stack}');
          return cb(null, [err]);
        }

        packageInfo._uplinks[upLink.upname] = {
          etag: eTag,
          fetched: Date.now()
        };
        packageInfo.time = (0, _storageUtils.mergeUplinkTimeIntoLocal)(packageInfo, upLinkResponse);
        (0, _uplinkUtil.updateVersionsHiddenUpLink)(upLinkResponse.versions, upLink);

        try {
          (0, _metadataUtils.mergeVersions)(packageInfo, upLinkResponse);
        } catch (err) {
          self.logger.error({
            sub: 'out',
            err: err
          }, 'package.json parsing error @{!err.message}\n@{err.stack}');
          return cb(null, [err]);
        } // if we got to this point, assume that the correct package exists
        // on the uplink


        found = true;
        cb();
      });
    }, // @ts-ignore
    (err, upLinksErrors) => {
      (0, _assert.default)(!err && Array.isArray(upLinksErrors)); // Check for connection timeout or reset errors with uplink(s)
      // (these should be handled differently from the package not being found)

      if (!found) {
        let uplinkTimeoutError;

        for (let i = 0; i < upLinksErrors.length; i++) {
          if (upLinksErrors[i]) {
            for (let j = 0; j < upLinksErrors[i].length; j++) {
              if (upLinksErrors[i][j]) {
                const code = upLinksErrors[i][j].code;

                if (code === 'ETIMEDOUT' || code === 'ESOCKETTIMEDOUT' || code === 'ECONNRESET') {
                  uplinkTimeoutError = true;
                  break;
                }
              }
            }
          }
        }

        if (uplinkTimeoutError) {
          return callback(_utils.ErrorCode.getServiceUnavailable(), null, upLinksErrors);
        } else {
          return callback(_utils.ErrorCode.getNotFound(_constants.API_ERROR.NO_PACKAGE), null, upLinksErrors);
        }
      }

      if (upLinks.length === 0) {
        return callback(null, packageInfo);
      }

      self.localStorage.updateVersions(name, packageInfo, async (err, packageJsonLocal) => {
        if (err) {
          return callback(err);
        } // Any error here will cause a 404, like an uplink error. This is likely the right thing to do
        // as a broken filter is a security risk.


        const filterErrors = []; // This MUST be done serially and not in parallel as they modify packageJsonLocal

        for (const filter of self.filters) {
          try {
            // These filters can assume it's save to modify packageJsonLocal and return it directly for
            // performance (i.e. need not be pure)
            packageJsonLocal = await filter.filter_metadata(packageJsonLocal);
          } catch (err) {
            filterErrors.push(err);
          }
        }

        callback(null, packageJsonLocal, _lodash.default.concat(upLinksErrors, filterErrors));
      });
    });
  }
  /**
   * Set a hidden value for each version.
   * @param {Array} versions list of version
   * @param {String} upLink uplink name
   * @private
   */


  _updateVersionsHiddenUpLink(versions, upLink) {
    for (const i in versions) {
      if (Object.prototype.hasOwnProperty.call(versions, i)) {
        const version = versions[i]; // holds a "hidden" value to be used by the package storage.
        // $FlowFixMe

        version[Symbol.for('__verdaccio_uplink')] = upLink.upname;
      }
    }
  }

}

var _default = Storage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvc3RvcmFnZS50cyJdLCJuYW1lcyI6WyJTdG9yYWdlIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJ1cGxpbmtzIiwibG9nZ2VyIiwiY2hpbGQiLCJmaWx0ZXJzIiwibG9jYWxTdG9yYWdlIiwiaW5pdCIsIkxvY2FsU3RvcmFnZSIsImdldFNlY3JldCIsImFkZFBhY2thZ2UiLCJuYW1lIiwibWV0YWRhdGEiLCJjYWxsYmFjayIsIl9pc0FsbG93UHVibGlzaE9mZmxpbmUiLCJfc3luY1VwbGlua3NNZXRhZGF0YSIsImJpbmQiLCJlcnIiLCJwdWJsaXNoIiwiXyIsImlzQm9vbGVhbiIsImFsbG93X29mZmxpbmUiLCJyZWFkVG9rZW5zIiwiZmlsdGVyIiwic2F2ZVRva2VuIiwidG9rZW4iLCJkZWxldGVUb2tlbiIsInVzZXIiLCJ0b2tlbktleSIsImFkZFZlcnNpb24iLCJ2ZXJzaW9uIiwidGFnIiwibWVyZ2VUYWdzIiwidGFnSGFzaCIsImNoYW5nZVBhY2thZ2UiLCJyZXZpc2lvbiIsInJlbW92ZVBhY2thZ2UiLCJTZWFyY2giLCJyZW1vdmUiLCJyZW1vdmVUYXJiYWxsIiwiZmlsZW5hbWUiLCJhZGRUYXJiYWxsIiwiZ2V0VGFyYmFsbCIsInJlYWRTdHJlYW0iLCJSZWFkVGFyYmFsbCIsImFib3J0Iiwic2VsZiIsImxvY2FsU3RyZWFtIiwiaXNPcGVuIiwib24iLCJzdGF0dXMiLCJIVFRQX1NUQVRVUyIsIk5PVF9GT1VORCIsImVtaXQiLCJlcnI0MDQiLCJnZXRQYWNrYWdlTWV0YWRhdGEiLCJpbmZvIiwiaXNOaWwiLCJfZGlzdGZpbGVzIiwic2VydmVGaWxlIiwidiIsInBpcGUiLCJmaWxlIiwidXBsaW5rIiwidXBsaW5rSWQiLCJpc1VwbGlua1ZhbGlkIiwidXJsIiwiUHJveHlTdG9yYWdlIiwiY2FjaGUiLCJfYXV0b2dlbmVyYXRlZCIsInNhdmVzdHJlYW0iLCJvbl9vcGVuIiwicnN0cmVhbTIiLCJmZXRjaFRhcmJhbGwiLCJkb25lIiwid2FybiIsImZpbGVOYW1lIiwiZ2V0UGFja2FnZSIsIm9wdGlvbnMiLCJkYXRhIiwiSU5URVJOQUxfRVJST1IiLCJyZXEiLCJ1cGxpbmtzTG9vayIsImdldFBhY2thZ2VTeW5VcExpbmtzQ2FsbGJhY2siLCJyZXN1bHQiLCJ1cGxpbmtFcnJvcnMiLCJrZWVwVXBMaW5rRGF0YSIsIl9hdHRhY2htZW50cyIsInNlYXJjaCIsInN0YXJ0a2V5Iiwic3RyZWFtIiwiU3RyZWFtIiwiUGFzc1Rocm91Z2giLCJvYmplY3RNb2RlIiwiYXN5bmMiLCJlYWNoU2VyaWVzIiwiT2JqZWN0Iiwia2V5cyIsInVwX25hbWUiLCJjYiIsInF1ZXJ5IiwibG9jYWwiLCJ1bmRlZmluZWQiLCJsc3RyZWFtIiwiZW5kIiwiZXJyb3IiLCJnZXRMb2NhbERhdGFiYXNlIiwic3RvcmFnZVBsdWdpbiIsImdldCIsImxvY2FscyIsInBhY2thZ2VzIiwiaXRlbVBrZyIsInBrZ01ldGFkYXRhIiwibGF0ZXN0IiwiRElTVF9UQUdTIiwidmVyc2lvbnMiLCJ0aW1lTGlzdCIsInRpbWUiLCJ1c2VycyIsInB1c2giLCJwYWNrYWdlIiwibGVuZ3RoIiwicGFja2FnZUluZm8iLCJmb3VuZCIsInVwTGlua3MiLCJoYXNUb0xvb2tJbnRvVXBsaW5rcyIsIm1hcCIsInVwTGluayIsIl9vcHRpb25zIiwiYXNzaWduIiwidXBMaW5rTWV0YSIsIl91cGxpbmtzIiwidXBuYW1lIiwiZmV0Y2hlZCIsIkRhdGUiLCJub3ciLCJtYXhhZ2UiLCJldGFnIiwiZ2V0UmVtb3RlTWV0YWRhdGEiLCJ1cExpbmtSZXNwb25zZSIsImVUYWciLCJyZW1vdGVTdGF0dXMiLCJFcnJvckNvZGUiLCJnZXRJbnRlcm5hbEVycm9yIiwic3ViIiwidXBMaW5rc0Vycm9ycyIsIkFycmF5IiwiaXNBcnJheSIsInVwbGlua1RpbWVvdXRFcnJvciIsImkiLCJqIiwiY29kZSIsImdldFNlcnZpY2VVbmF2YWlsYWJsZSIsImdldE5vdEZvdW5kIiwiQVBJX0VSUk9SIiwiTk9fUEFDS0FHRSIsInVwZGF0ZVZlcnNpb25zIiwicGFja2FnZUpzb25Mb2NhbCIsImZpbHRlckVycm9ycyIsImZpbHRlcl9tZXRhZGF0YSIsImNvbmNhdCIsIl91cGRhdGVWZXJzaW9uc0hpZGRlblVwTGluayIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIlN5bWJvbCIsImZvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBOztBQUNBOzs7Ozs7QUFJQSxNQUFNQSxPQUFOLENBQXlDO0FBT2hDQyxFQUFBQSxXQUFQLENBQW1CQyxNQUFuQixFQUFtQztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUFBOztBQUNqQyxTQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLQyxPQUFMLEdBQWUsOEJBQWFELE1BQWIsQ0FBZjtBQUNBLFNBQUtFLE1BQUwsR0FBY0EsZUFBT0MsS0FBUCxFQUFkO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLEVBQWYsQ0FKaUMsQ0FLakM7O0FBQ0EsU0FBS0MsWUFBTCxHQUFvQixJQUFwQjtBQUNEOztBQUVNQyxFQUFBQSxJQUFQLENBQVlOLE1BQVosRUFBNEJJLE9BQXVCLEdBQUcsRUFBdEQsRUFBMkU7QUFDekUsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQixJQUFJRSxxQkFBSixDQUFpQixLQUFLUCxNQUF0QixFQUE4QkUsY0FBOUIsQ0FBcEI7QUFFQSxXQUFPLEtBQUtHLFlBQUwsQ0FBa0JHLFNBQWxCLENBQTRCUixNQUE1QixDQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7QUFNQSxRQUFhUyxVQUFiLENBQXdCQyxJQUF4QixFQUFzQ0MsUUFBdEMsRUFBcURDLFFBQXJELEVBQXdGO0FBQ3RGLFFBQUk7QUFDRixZQUFNLHFDQUFrQkYsSUFBbEIsRUFBd0IsS0FBS0wsWUFBN0IsQ0FBTjtBQUNBLFlBQU0sc0NBQW1CSyxJQUFuQixFQUF5QixLQUFLRyxzQkFBTCxFQUF6QixFQUF3RCxLQUFLQyxvQkFBTCxDQUEwQkMsSUFBMUIsQ0FBK0IsSUFBL0IsQ0FBeEQsQ0FBTjtBQUNBLFlBQU0sa0NBQWVMLElBQWYsRUFBcUJDLFFBQXJCLEVBQStCLEtBQUtOLFlBQXBDLENBQU47QUFDQU8sTUFBQUEsUUFBUTtBQUNULEtBTEQsQ0FLRSxPQUFPSSxHQUFQLEVBQVk7QUFDWkosTUFBQUEsUUFBUSxDQUFDSSxHQUFELENBQVI7QUFDRDtBQUNGOztBQUVPSCxFQUFBQSxzQkFBUixHQUEwQztBQUN4QyxXQUFPLE9BQU8sS0FBS2IsTUFBTCxDQUFZaUIsT0FBbkIsS0FBK0IsV0FBL0IsSUFBOENDLGdCQUFFQyxTQUFGLENBQVksS0FBS25CLE1BQUwsQ0FBWWlCLE9BQVosQ0FBb0JHLGFBQWhDLENBQTlDLElBQWdHLEtBQUtwQixNQUFMLENBQVlpQixPQUFaLENBQW9CRyxhQUEzSDtBQUNEOztBQUVNQyxFQUFBQSxVQUFQLENBQWtCQyxNQUFsQixFQUE4RDtBQUM1RCxXQUFPLEtBQUtqQixZQUFMLENBQWtCZ0IsVUFBbEIsQ0FBNkJDLE1BQTdCLENBQVA7QUFDRDs7QUFFTUMsRUFBQUEsU0FBUCxDQUFpQkMsS0FBakIsRUFBOEM7QUFDNUMsV0FBTyxLQUFLbkIsWUFBTCxDQUFrQmtCLFNBQWxCLENBQTRCQyxLQUE1QixDQUFQO0FBQ0Q7O0FBRU1DLEVBQUFBLFdBQVAsQ0FBbUJDLElBQW5CLEVBQWlDQyxRQUFqQyxFQUFpRTtBQUMvRCxXQUFPLEtBQUt0QixZQUFMLENBQWtCb0IsV0FBbEIsQ0FBOEJDLElBQTlCLEVBQW9DQyxRQUFwQyxDQUFQO0FBQ0Q7QUFFRDs7Ozs7O0FBSU9DLEVBQUFBLFVBQVAsQ0FBa0JsQixJQUFsQixFQUFnQ21CLE9BQWhDLEVBQWlEbEIsUUFBakQsRUFBb0VtQixHQUFwRSxFQUFzRmxCLFFBQXRGLEVBQWdIO0FBQzlHLFNBQUtQLFlBQUwsQ0FBa0J1QixVQUFsQixDQUE2QmxCLElBQTdCLEVBQW1DbUIsT0FBbkMsRUFBNENsQixRQUE1QyxFQUFzRG1CLEdBQXRELEVBQTJEbEIsUUFBM0Q7QUFDRDtBQUVEOzs7Ozs7QUFJT21CLEVBQUFBLFNBQVAsQ0FBaUJyQixJQUFqQixFQUErQnNCLE9BQS9CLEVBQW1EcEIsUUFBbkQsRUFBNkU7QUFDM0UsU0FBS1AsWUFBTCxDQUFrQjBCLFNBQWxCLENBQTRCckIsSUFBNUIsRUFBa0NzQixPQUFsQyxFQUEyQ3BCLFFBQTNDO0FBQ0Q7QUFFRDs7Ozs7OztBQUtPcUIsRUFBQUEsYUFBUCxDQUFxQnZCLElBQXJCLEVBQW1DQyxRQUFuQyxFQUFzRHVCLFFBQXRELEVBQXdFdEIsUUFBeEUsRUFBa0c7QUFDaEcsU0FBS1AsWUFBTCxDQUFrQjRCLGFBQWxCLENBQWdDdkIsSUFBaEMsRUFBc0NDLFFBQXRDLEVBQWdEdUIsUUFBaEQsRUFBMER0QixRQUExRDtBQUNEO0FBRUQ7Ozs7Ozs7QUFLT3VCLEVBQUFBLGFBQVAsQ0FBcUJ6QixJQUFyQixFQUFtQ0UsUUFBbkMsRUFBNkQ7QUFDM0QsU0FBS1AsWUFBTCxDQUFrQjhCLGFBQWxCLENBQWdDekIsSUFBaEMsRUFBc0NFLFFBQXRDLEVBRDJELENBRTNEOztBQUNBd0Isb0JBQU9DLE1BQVAsQ0FBYzNCLElBQWQ7QUFDRDtBQUVEOzs7Ozs7Ozs7QUFPTzRCLEVBQUFBLGFBQVAsQ0FBcUI1QixJQUFyQixFQUFtQzZCLFFBQW5DLEVBQXFETCxRQUFyRCxFQUF1RXRCLFFBQXZFLEVBQWlHO0FBQy9GLFNBQUtQLFlBQUwsQ0FBa0JpQyxhQUFsQixDQUFnQzVCLElBQWhDLEVBQXNDNkIsUUFBdEMsRUFBZ0RMLFFBQWhELEVBQTBEdEIsUUFBMUQ7QUFDRDtBQUVEOzs7Ozs7O0FBS080QixFQUFBQSxVQUFQLENBQWtCOUIsSUFBbEIsRUFBZ0M2QixRQUFoQyxFQUFrRTtBQUNoRSxXQUFPLEtBQUtsQyxZQUFMLENBQWtCbUMsVUFBbEIsQ0FBNkI5QixJQUE3QixFQUFtQzZCLFFBQW5DLENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7QUFPT0UsRUFBQUEsVUFBUCxDQUFrQi9CLElBQWxCLEVBQWdDNkIsUUFBaEMsRUFBZ0U7QUFDOUQsVUFBTUcsVUFBVSxHQUFHLElBQUlDLG9CQUFKLENBQWdCLEVBQWhCLENBQW5COztBQUNBRCxJQUFBQSxVQUFVLENBQUNFLEtBQVgsR0FBbUIsWUFBVyxDQUFFLENBQWhDOztBQUVBLFVBQU1DLElBQUksR0FBRyxJQUFiLENBSjhELENBTTlEO0FBQ0E7QUFFQTtBQUNBOztBQUNBLFFBQUlDLFdBQWdCLEdBQUdELElBQUksQ0FBQ3hDLFlBQUwsQ0FBa0JvQyxVQUFsQixDQUE2Qi9CLElBQTdCLEVBQW1DNkIsUUFBbkMsQ0FBdkI7QUFDQSxRQUFJUSxNQUFNLEdBQUcsS0FBYjtBQUNBRCxJQUFBQSxXQUFXLENBQUNFLEVBQVosQ0FDRSxPQURGLEVBRUdoQyxHQUFELElBQWM7QUFDWixVQUFJK0IsTUFBTSxJQUFJL0IsR0FBRyxDQUFDaUMsTUFBSixLQUFlQyx1QkFBWUMsU0FBekMsRUFBb0Q7QUFDbEQsZUFBT1QsVUFBVSxDQUFDVSxJQUFYLENBQWdCLE9BQWhCLEVBQXlCcEMsR0FBekIsQ0FBUDtBQUNELE9BSFcsQ0FLWjs7O0FBQ0EsWUFBTXFDLE1BQU0sR0FBR3JDLEdBQWY7QUFDQThCLE1BQUFBLFdBQVcsQ0FBQ0YsS0FBWjtBQUNBRSxNQUFBQSxXQUFXLEdBQUcsSUFBZCxDQVJZLENBUVE7O0FBQ3BCRCxNQUFBQSxJQUFJLENBQUN4QyxZQUFMLENBQWtCaUQsa0JBQWxCLENBQ0U1QyxJQURGLEVBRUUsQ0FBQ00sR0FBRCxFQUFNdUMsSUFBTixLQUE4QjtBQUM1QixZQUFJckMsZ0JBQUVzQyxLQUFGLENBQVF4QyxHQUFSLEtBQWdCdUMsSUFBSSxDQUFDRSxVQUFyQixJQUFtQ3ZDLGdCQUFFc0MsS0FBRixDQUFRRCxJQUFJLENBQUNFLFVBQUwsQ0FBZ0JsQixRQUFoQixDQUFSLE1BQXVDLEtBQTlFLEVBQXFGO0FBQ25GO0FBQ0FtQixVQUFBQSxTQUFTLENBQUNILElBQUksQ0FBQ0UsVUFBTCxDQUFnQmxCLFFBQWhCLENBQUQsQ0FBVDtBQUNELFNBSEQsTUFHTztBQUNMO0FBQ0FNLFVBQUFBLElBQUksQ0FBQy9CLG9CQUFMLENBQ0VKLElBREYsRUFFRTZDLElBRkYsRUFHRSxFQUhGLEVBSUUsQ0FBQ3ZDLEdBQUQsRUFBTXVDLElBQU4sS0FBNkI7QUFDM0IsZ0JBQUlyQyxnQkFBRXNDLEtBQUYsQ0FBUXhDLEdBQVIsTUFBaUIsS0FBckIsRUFBNEI7QUFDMUIscUJBQU8wQixVQUFVLENBQUNVLElBQVgsQ0FBZ0IsT0FBaEIsRUFBeUJwQyxHQUF6QixDQUFQO0FBQ0Q7O0FBQ0QsZ0JBQUlFLGdCQUFFc0MsS0FBRixDQUFRRCxJQUFJLENBQUNFLFVBQWIsS0FBNEJ2QyxnQkFBRXNDLEtBQUYsQ0FBUUQsSUFBSSxDQUFDRSxVQUFMLENBQWdCbEIsUUFBaEIsQ0FBUixDQUFoQyxFQUFvRTtBQUNsRSxxQkFBT0csVUFBVSxDQUFDVSxJQUFYLENBQWdCLE9BQWhCLEVBQXlCQyxNQUF6QixDQUFQO0FBQ0Q7O0FBQ0RLLFlBQUFBLFNBQVMsQ0FBQ0gsSUFBSSxDQUFDRSxVQUFMLENBQWdCbEIsUUFBaEIsQ0FBRCxDQUFUO0FBQ0QsV0FaSDtBQWNEO0FBQ0YsT0F2Qkg7QUF5QkQsS0FwQ0g7QUFzQ0FPLElBQUFBLFdBQVcsQ0FBQ0UsRUFBWixDQUFlLGdCQUFmLEVBQWlDLFVBQVNXLENBQVQsRUFBa0I7QUFDakRqQixNQUFBQSxVQUFVLENBQUNVLElBQVgsQ0FBZ0IsZ0JBQWhCLEVBQWtDTyxDQUFsQztBQUNELEtBRkQ7QUFHQWIsSUFBQUEsV0FBVyxDQUFDRSxFQUFaLENBQWUsTUFBZixFQUF1QixZQUFpQjtBQUN0Q0QsTUFBQUEsTUFBTSxHQUFHLElBQVQ7QUFDQUQsTUFBQUEsV0FBVyxDQUFDYyxJQUFaLENBQWlCbEIsVUFBakI7QUFDRCxLQUhEO0FBSUEsV0FBT0EsVUFBUDtBQUVBOzs7OztBQUlBLGFBQVNnQixTQUFULENBQW1CRyxJQUFuQixFQUF5QztBQUN2QyxVQUFJQyxNQUFXLEdBQUcsSUFBbEI7O0FBRUEsV0FBSyxNQUFNQyxRQUFYLElBQXVCbEIsSUFBSSxDQUFDNUMsT0FBNUIsRUFBcUM7QUFDbkMsWUFBSTRDLElBQUksQ0FBQzVDLE9BQUwsQ0FBYThELFFBQWIsRUFBdUJDLGFBQXZCLENBQXFDSCxJQUFJLENBQUNJLEdBQTFDLENBQUosRUFBb0Q7QUFDbERILFVBQUFBLE1BQU0sR0FBR2pCLElBQUksQ0FBQzVDLE9BQUwsQ0FBYThELFFBQWIsQ0FBVDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSUQsTUFBTSxJQUFJLElBQWQsRUFBb0I7QUFDbEJBLFFBQUFBLE1BQU0sR0FBRyxJQUFJSSxrQkFBSixDQUNQO0FBQ0VELFVBQUFBLEdBQUcsRUFBRUosSUFBSSxDQUFDSSxHQURaO0FBRUVFLFVBQUFBLEtBQUssRUFBRSxJQUZUO0FBR0VDLFVBQUFBLGNBQWMsRUFBRTtBQUhsQixTQURPLEVBTVB2QixJQUFJLENBQUM3QyxNQU5FLENBQVQ7QUFRRDs7QUFFRCxVQUFJcUUsVUFBaUMsR0FBRyxJQUF4Qzs7QUFDQSxVQUFJUCxNQUFNLENBQUM5RCxNQUFQLENBQWNtRSxLQUFsQixFQUF5QjtBQUN2QkUsUUFBQUEsVUFBVSxHQUFHeEIsSUFBSSxDQUFDeEMsWUFBTCxDQUFrQm1DLFVBQWxCLENBQTZCOUIsSUFBN0IsRUFBbUM2QixRQUFuQyxDQUFiO0FBQ0Q7O0FBRUQsVUFBSStCLE9BQU8sR0FBRyxZQUFpQjtBQUM3QjtBQUNBQSxRQUFBQSxPQUFPLEdBQUcsWUFBVyxDQUFFLENBQXZCOztBQUNBLGNBQU1DLFFBQVEsR0FBR1QsTUFBTSxDQUFDVSxZQUFQLENBQW9CWCxJQUFJLENBQUNJLEdBQXpCLENBQWpCO0FBQ0FNLFFBQUFBLFFBQVEsQ0FBQ3ZCLEVBQVQsQ0FBWSxPQUFaLEVBQXFCLFVBQVNoQyxHQUFULEVBQW9CO0FBQ3ZDLGNBQUlxRCxVQUFKLEVBQWdCO0FBQ2RBLFlBQUFBLFVBQVUsQ0FBQ3pCLEtBQVg7QUFDRDs7QUFDRHlCLFVBQUFBLFVBQVUsR0FBRyxJQUFiO0FBQ0EzQixVQUFBQSxVQUFVLENBQUNVLElBQVgsQ0FBZ0IsT0FBaEIsRUFBeUJwQyxHQUF6QjtBQUNELFNBTkQ7QUFPQXVELFFBQUFBLFFBQVEsQ0FBQ3ZCLEVBQVQsQ0FBWSxLQUFaLEVBQW1CLFlBQWlCO0FBQ2xDLGNBQUlxQixVQUFKLEVBQWdCO0FBQ2RBLFlBQUFBLFVBQVUsQ0FBQ0ksSUFBWDtBQUNEO0FBQ0YsU0FKRDtBQU1BRixRQUFBQSxRQUFRLENBQUN2QixFQUFULENBQVksZ0JBQVosRUFBOEIsVUFBU1csQ0FBVCxFQUFrQjtBQUM5Q2pCLFVBQUFBLFVBQVUsQ0FBQ1UsSUFBWCxDQUFnQixnQkFBaEIsRUFBa0NPLENBQWxDOztBQUNBLGNBQUlVLFVBQUosRUFBZ0I7QUFDZEEsWUFBQUEsVUFBVSxDQUFDakIsSUFBWCxDQUFnQixnQkFBaEIsRUFBa0NPLENBQWxDO0FBQ0Q7QUFDRixTQUxEO0FBTUFZLFFBQUFBLFFBQVEsQ0FBQ1gsSUFBVCxDQUFjbEIsVUFBZDs7QUFDQSxZQUFJMkIsVUFBSixFQUFnQjtBQUNkRSxVQUFBQSxRQUFRLENBQUNYLElBQVQsQ0FBY1MsVUFBZDtBQUNEO0FBQ0YsT0EzQkQ7O0FBNkJBLFVBQUlBLFVBQUosRUFBZ0I7QUFDZEEsUUFBQUEsVUFBVSxDQUFDckIsRUFBWCxDQUFjLE1BQWQsRUFBc0IsWUFBaUI7QUFDckNzQixVQUFBQSxPQUFPO0FBQ1IsU0FGRDtBQUlBRCxRQUFBQSxVQUFVLENBQUNyQixFQUFYLENBQWMsT0FBZCxFQUF1QixVQUFTaEMsR0FBVCxFQUFvQjtBQUN6QzZCLFVBQUFBLElBQUksQ0FBQzNDLE1BQUwsQ0FBWXdFLElBQVosQ0FBaUI7QUFBRTFELFlBQUFBLEdBQUcsRUFBRUEsR0FBUDtBQUFZMkQsWUFBQUEsUUFBUSxFQUFFZDtBQUF0QixXQUFqQixFQUErQyw2REFBL0M7O0FBQ0EsY0FBSVEsVUFBSixFQUFnQjtBQUNkQSxZQUFBQSxVQUFVLENBQUN6QixLQUFYO0FBQ0Q7O0FBQ0R5QixVQUFBQSxVQUFVLEdBQUcsSUFBYjtBQUNBQyxVQUFBQSxPQUFPO0FBQ1IsU0FQRDtBQVFELE9BYkQsTUFhTztBQUNMQSxRQUFBQSxPQUFPO0FBQ1I7QUFDRjtBQUNGO0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FBYU9NLEVBQUFBLFVBQVAsQ0FBa0JDLE9BQWxCLEVBQXFEO0FBQ25ELFNBQUt4RSxZQUFMLENBQWtCaUQsa0JBQWxCLENBQ0V1QixPQUFPLENBQUNuRSxJQURWLEVBRUUsQ0FBQ00sR0FBRCxFQUFNOEQsSUFBTixLQUFxQjtBQUNuQixVQUFJOUQsR0FBRyxLQUFLLENBQUNBLEdBQUcsQ0FBQ2lDLE1BQUwsSUFBZWpDLEdBQUcsQ0FBQ2lDLE1BQUosSUFBY0MsdUJBQVk2QixjQUE5QyxDQUFQLEVBQXNFO0FBQ3BFO0FBQ0EsZUFBT0YsT0FBTyxDQUFDakUsUUFBUixDQUFpQkksR0FBakIsQ0FBUDtBQUNEOztBQUVELFdBQUtGLG9CQUFMLENBQTBCK0QsT0FBTyxDQUFDbkUsSUFBbEMsRUFBd0NvRSxJQUF4QyxFQUE4QztBQUFFRSxRQUFBQSxHQUFHLEVBQUVILE9BQU8sQ0FBQ0csR0FBZjtBQUFvQkMsUUFBQUEsV0FBVyxFQUFFSixPQUFPLENBQUNJO0FBQXpDLE9BQTlDLEVBQXNHLFNBQVNDLDRCQUFULENBQ3BHbEUsR0FEb0csRUFFcEdtRSxNQUZvRyxFQUdwR0MsWUFIb0csRUFJOUY7QUFDTixZQUFJcEUsR0FBSixFQUFTO0FBQ1AsaUJBQU82RCxPQUFPLENBQUNqRSxRQUFSLENBQWlCSSxHQUFqQixDQUFQO0FBQ0Q7O0FBRUQsc0NBQWtCLG1DQUFnQjZELE9BQU8sQ0FBQ1EsY0FBeEIsRUFBd0NGLE1BQXhDLENBQWxCLEVBTE0sQ0FPTjs7QUFDQUEsUUFBQUEsTUFBTSxDQUFDRyxZQUFQLEdBQXNCLEVBQXRCO0FBRUFULFFBQUFBLE9BQU8sQ0FBQ2pFLFFBQVIsQ0FBaUIsSUFBakIsRUFBdUJ1RSxNQUF2QixFQUErQkMsWUFBL0I7QUFDRCxPQWZEO0FBZ0JELEtBeEJIO0FBMEJEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FBWU9HLEVBQUFBLE1BQVAsQ0FBY0MsUUFBZCxFQUFnQ1gsT0FBaEMsRUFBNEQ7QUFDMUQsVUFBTWhDLElBQUksR0FBRyxJQUFiLENBRDBELENBRTFEOztBQUNBLFVBQU00QyxNQUFXLEdBQUcsSUFBSUMsZ0JBQU9DLFdBQVgsQ0FBdUI7QUFBRUMsTUFBQUEsVUFBVSxFQUFFO0FBQWQsS0FBdkIsQ0FBcEI7O0FBRUFDLG1CQUFNQyxVQUFOLENBQ0VDLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZLEtBQUsvRixPQUFqQixDQURGLEVBRUUsVUFBU2dHLE9BQVQsRUFBa0JDLEVBQWxCLEVBQTRCO0FBQzFCO0FBQ0EsVUFBSXJCLE9BQU8sQ0FBQ0csR0FBUixDQUFZbUIsS0FBWixDQUFrQkMsS0FBbEIsS0FBNEJDLFNBQWhDLEVBQTJDO0FBQ3pDLGVBQU9ILEVBQUUsRUFBVDtBQUNELE9BSnlCLENBSzFCOzs7QUFDQSxZQUFNSSxPQUF1QixHQUFHekQsSUFBSSxDQUFDNUMsT0FBTCxDQUFhZ0csT0FBYixFQUFzQlYsTUFBdEIsQ0FBNkJWLE9BQTdCLENBQWhDLENBTjBCLENBTzFCOztBQUNBeUIsTUFBQUEsT0FBTyxDQUFDMUMsSUFBUixDQUNFNkIsTUFERixFQUVFO0FBQUVjLFFBQUFBLEdBQUcsRUFBRTtBQUFQLE9BRkY7QUFJQUQsTUFBQUEsT0FBTyxDQUFDdEQsRUFBUixDQUFXLE9BQVgsRUFBb0IsVUFBU2hDLEdBQVQsRUFBb0I7QUFDdEM2QixRQUFBQSxJQUFJLENBQUMzQyxNQUFMLENBQVlzRyxLQUFaLENBQWtCO0FBQUV4RixVQUFBQSxHQUFHLEVBQUVBO0FBQVAsU0FBbEIsRUFBZ0MsOEJBQWhDO0FBQ0FrRixRQUFBQSxFQUFFOztBQUNGQSxRQUFBQSxFQUFFLEdBQUcsWUFBaUIsQ0FBRSxDQUF4QjtBQUNELE9BSkQ7QUFLQUksTUFBQUEsT0FBTyxDQUFDdEQsRUFBUixDQUFXLEtBQVgsRUFBa0IsWUFBaUI7QUFDakNrRCxRQUFBQSxFQUFFOztBQUNGQSxRQUFBQSxFQUFFLEdBQUcsWUFBaUIsQ0FBRSxDQUF4QjtBQUNELE9BSEQ7O0FBS0FULE1BQUFBLE1BQU0sQ0FBQzdDLEtBQVAsR0FBZSxZQUFpQjtBQUM5QixZQUFJMEQsT0FBTyxDQUFDMUQsS0FBWixFQUFtQjtBQUNqQjBELFVBQUFBLE9BQU8sQ0FBQzFELEtBQVI7QUFDRDs7QUFDRHNELFFBQUFBLEVBQUU7O0FBQ0ZBLFFBQUFBLEVBQUUsR0FBRyxZQUFpQixDQUFFLENBQXhCO0FBQ0QsT0FORDtBQU9ELEtBL0JILEVBZ0NFO0FBQ0EsZ0JBQWlCO0FBQ2Y7QUFDQSxZQUFNSSxPQUFxQixHQUFHekQsSUFBSSxDQUFDeEMsWUFBTCxDQUFrQmtGLE1BQWxCLENBQXlCQyxRQUF6QixFQUFtQ1gsT0FBbkMsQ0FBOUI7O0FBQ0FZLE1BQUFBLE1BQU0sQ0FBQzdDLEtBQVAsR0FBZSxZQUFpQjtBQUM5QjBELFFBQUFBLE9BQU8sQ0FBQzFELEtBQVI7QUFDRCxPQUZEOztBQUdBMEQsTUFBQUEsT0FBTyxDQUFDMUMsSUFBUixDQUNFNkIsTUFERixFQUVFO0FBQUVjLFFBQUFBLEdBQUcsRUFBRTtBQUFQLE9BRkY7QUFJQUQsTUFBQUEsT0FBTyxDQUFDdEQsRUFBUixDQUFXLE9BQVgsRUFBb0IsVUFBU2hDLEdBQVQsRUFBb0M7QUFDdEQ2QixRQUFBQSxJQUFJLENBQUMzQyxNQUFMLENBQVlzRyxLQUFaLENBQWtCO0FBQUV4RixVQUFBQSxHQUFHLEVBQUVBO0FBQVAsU0FBbEIsRUFBZ0MsOEJBQWhDO0FBQ0F5RSxRQUFBQSxNQUFNLENBQUNjLEdBQVA7QUFDRCxPQUhEO0FBSUQsS0EvQ0g7O0FBa0RBLFdBQU9kLE1BQVA7QUFDRDtBQUVEOzs7Ozs7QUFJT2dCLEVBQUFBLGdCQUFQLENBQXdCN0YsUUFBeEIsRUFBa0Q7QUFDaEQsVUFBTWlDLElBQUksR0FBRyxJQUFiO0FBQ0EsU0FBS3hDLFlBQUwsQ0FBa0JxRyxhQUFsQixDQUFnQ0MsR0FBaEMsQ0FDRSxDQUFDM0YsR0FBRCxFQUFNNEYsTUFBTixLQUF1QjtBQUNyQixVQUFJNUYsR0FBSixFQUFTO0FBQ1BKLFFBQUFBLFFBQVEsQ0FBQ0ksR0FBRCxDQUFSO0FBQ0Q7O0FBRUQsWUFBTTZGLFFBQW1CLEdBQUcsRUFBNUI7O0FBQ0EsWUFBTWpDLFVBQVUsR0FBRyxVQUFTa0MsT0FBVCxFQUF3QjtBQUN6Q2pFLFFBQUFBLElBQUksQ0FBQ3hDLFlBQUwsQ0FBa0JpRCxrQkFBbEIsQ0FBcUNzRCxNQUFNLENBQUNFLE9BQUQsQ0FBM0MsRUFBc0QsVUFBUzlGLEdBQVQsRUFBYytGLFdBQWQsRUFBMEM7QUFDOUYsY0FBSTdGLGdCQUFFc0MsS0FBRixDQUFReEMsR0FBUixDQUFKLEVBQWtCO0FBQ2hCLGtCQUFNZ0csTUFBTSxHQUFHRCxXQUFXLENBQUNFLG9CQUFELENBQVgsQ0FBdUJELE1BQXRDOztBQUNBLGdCQUFJQSxNQUFNLElBQUlELFdBQVcsQ0FBQ0csUUFBWixDQUFxQkYsTUFBckIsQ0FBZCxFQUE0QztBQUMxQyxvQkFBTW5GLE9BQWdCLEdBQUdrRixXQUFXLENBQUNHLFFBQVosQ0FBcUJGLE1BQXJCLENBQXpCO0FBQ0Esb0JBQU1HLFFBQVEsR0FBR0osV0FBVyxDQUFDSyxJQUE3QjtBQUNBLG9CQUFNQSxJQUFJLEdBQUdELFFBQVEsQ0FBQ0gsTUFBRCxDQUFyQixDQUgwQyxDQUkxQzs7QUFDQW5GLGNBQUFBLE9BQU8sQ0FBQ3VGLElBQVIsR0FBZUEsSUFBZixDQUwwQyxDQU8xQztBQUNBOztBQUNBdkYsY0FBQUEsT0FBTyxDQUFDd0YsS0FBUixHQUFnQk4sV0FBVyxDQUFDTSxLQUE1QjtBQUVBUixjQUFBQSxRQUFRLENBQUNTLElBQVQsQ0FBY3pGLE9BQWQ7QUFDRCxhQVpELE1BWU87QUFDTGdCLGNBQUFBLElBQUksQ0FBQzNDLE1BQUwsQ0FBWXdFLElBQVosQ0FBaUI7QUFBRTZDLGdCQUFBQSxPQUFPLEVBQUVYLE1BQU0sQ0FBQ0UsT0FBRDtBQUFqQixlQUFqQixFQUErQyxrREFBL0M7QUFDRDtBQUNGOztBQUVELGNBQUlBLE9BQU8sSUFBSUYsTUFBTSxDQUFDWSxNQUFQLEdBQWdCLENBQS9CLEVBQWtDO0FBQ2hDNUcsWUFBQUEsUUFBUSxDQUFDLElBQUQsRUFBT2lHLFFBQVAsQ0FBUjtBQUNELFdBRkQsTUFFTztBQUNMakMsWUFBQUEsVUFBVSxDQUFDa0MsT0FBTyxHQUFHLENBQVgsQ0FBVjtBQUNEO0FBQ0YsU0F6QkQ7QUEwQkQsT0EzQkQ7O0FBNkJBLFVBQUlGLE1BQU0sQ0FBQ1ksTUFBWCxFQUFtQjtBQUNqQjVDLFFBQUFBLFVBQVUsQ0FBQyxDQUFELENBQVY7QUFDRCxPQUZELE1BRU87QUFDTGhFLFFBQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU8sRUFBUCxDQUFSO0FBQ0Q7QUFDRixLQXpDSDtBQTJDRDtBQUVEOzs7Ozs7O0FBS09FLEVBQUFBLG9CQUFQLENBQTRCSixJQUE1QixFQUEwQytHLFdBQTFDLEVBQWdFNUMsT0FBaEUsRUFBdUZqRSxRQUF2RixFQUFpSDtBQUMvRyxRQUFJOEcsS0FBSyxHQUFHLElBQVo7QUFDQSxVQUFNN0UsSUFBSSxHQUFHLElBQWI7QUFDQSxVQUFNOEUsT0FBaUIsR0FBRyxFQUExQjtBQUNBLFVBQU1DLG9CQUFvQixHQUFHMUcsZ0JBQUVzQyxLQUFGLENBQVFxQixPQUFPLENBQUNJLFdBQWhCLEtBQWdDSixPQUFPLENBQUNJLFdBQXJFOztBQUVBLFFBQUksQ0FBQ3dDLFdBQUwsRUFBa0I7QUFDaEJDLE1BQUFBLEtBQUssR0FBRyxLQUFSO0FBQ0FELE1BQUFBLFdBQVcsR0FBRywyQ0FBd0IvRyxJQUF4QixDQUFkO0FBQ0Q7O0FBRUQsU0FBSyxNQUFNb0QsTUFBWCxJQUFxQixLQUFLN0QsT0FBMUIsRUFBbUM7QUFDakMsVUFBSSw2QkFBV1MsSUFBWCxFQUFpQm9ELE1BQWpCLEVBQXlCLEtBQUs5RCxNQUFMLENBQVk2RyxRQUFyQyxLQUFrRGUsb0JBQXRELEVBQTRFO0FBQzFFRCxRQUFBQSxPQUFPLENBQUNMLElBQVIsQ0FBYSxLQUFLckgsT0FBTCxDQUFhNkQsTUFBYixDQUFiO0FBQ0Q7QUFDRjs7QUFFRCtCLG1CQUFNZ0MsR0FBTixDQUNFRixPQURGLEVBRUUsQ0FBQ0csTUFBRCxFQUFTNUIsRUFBVCxLQUFzQjtBQUNwQixZQUFNNkIsUUFBUSxHQUFHaEMsTUFBTSxDQUFDaUMsTUFBUCxDQUFjLEVBQWQsRUFBa0JuRCxPQUFsQixDQUFqQjs7QUFDQSxZQUFNb0QsVUFBVSxHQUFHUixXQUFXLENBQUNTLFFBQVosQ0FBcUJKLE1BQU0sQ0FBQ0ssTUFBNUIsQ0FBbkI7O0FBRUEsVUFBSSxxQkFBU0YsVUFBVCxDQUFKLEVBQTBCO0FBQ3hCLGNBQU1HLE9BQU8sR0FBR0gsVUFBVSxDQUFDRyxPQUEzQjs7QUFFQSxZQUFJQSxPQUFPLElBQUlDLElBQUksQ0FBQ0MsR0FBTCxLQUFhRixPQUFiLEdBQXVCTixNQUFNLENBQUNTLE1BQTdDLEVBQXFEO0FBQ25ELGlCQUFPckMsRUFBRSxFQUFUO0FBQ0Q7O0FBRUQ2QixRQUFBQSxRQUFRLENBQUNTLElBQVQsR0FBZ0JQLFVBQVUsQ0FBQ08sSUFBM0I7QUFDRDs7QUFFRFYsTUFBQUEsTUFBTSxDQUFDVyxpQkFBUCxDQUNFL0gsSUFERixFQUVFcUgsUUFGRixFQUdFLENBQUMvRyxHQUFELEVBQU0wSCxjQUFOLEVBQXNCQyxJQUF0QixLQUFxQztBQUNuQyxZQUFJM0gsR0FBRyxJQUFJQSxHQUFHLENBQUM0SCxZQUFKLEtBQXFCLEdBQWhDLEVBQXFDO0FBQ25DWCxVQUFBQSxVQUFVLENBQUNHLE9BQVgsR0FBcUJDLElBQUksQ0FBQ0MsR0FBTCxFQUFyQjtBQUNEOztBQUVELFlBQUl0SCxHQUFHLElBQUksQ0FBQzBILGNBQVosRUFBNEI7QUFDMUIsaUJBQU94QyxFQUFFLENBQUMsSUFBRCxFQUFPLENBQUNsRixHQUFHLElBQUk2SCxpQkFBVUMsZ0JBQVYsQ0FBMkIsU0FBM0IsQ0FBUixDQUFQLENBQVQ7QUFDRDs7QUFFRCxZQUFJO0FBQ0YsdUNBQWlCSixjQUFqQixFQUFpQ2hJLElBQWpDO0FBQ0QsU0FGRCxDQUVFLE9BQU9NLEdBQVAsRUFBWTtBQUNaNkIsVUFBQUEsSUFBSSxDQUFDM0MsTUFBTCxDQUFZc0csS0FBWixDQUNFO0FBQ0V1QyxZQUFBQSxHQUFHLEVBQUUsS0FEUDtBQUVFL0gsWUFBQUEsR0FBRyxFQUFFQTtBQUZQLFdBREYsRUFLRSw2REFMRjtBQU9BLGlCQUFPa0YsRUFBRSxDQUFDLElBQUQsRUFBTyxDQUFDbEYsR0FBRCxDQUFQLENBQVQ7QUFDRDs7QUFFRHlHLFFBQUFBLFdBQVcsQ0FBQ1MsUUFBWixDQUFxQkosTUFBTSxDQUFDSyxNQUE1QixJQUFzQztBQUNwQ0ssVUFBQUEsSUFBSSxFQUFFRyxJQUQ4QjtBQUVwQ1AsVUFBQUEsT0FBTyxFQUFFQyxJQUFJLENBQUNDLEdBQUw7QUFGMkIsU0FBdEM7QUFLQWIsUUFBQUEsV0FBVyxDQUFDTCxJQUFaLEdBQW1CLDRDQUF5QkssV0FBekIsRUFBc0NpQixjQUF0QyxDQUFuQjtBQUVBLG9EQUEyQkEsY0FBYyxDQUFDeEIsUUFBMUMsRUFBb0RZLE1BQXBEOztBQUVBLFlBQUk7QUFDRiw0Q0FBY0wsV0FBZCxFQUEyQmlCLGNBQTNCO0FBQ0QsU0FGRCxDQUVFLE9BQU8xSCxHQUFQLEVBQVk7QUFDWjZCLFVBQUFBLElBQUksQ0FBQzNDLE1BQUwsQ0FBWXNHLEtBQVosQ0FDRTtBQUNFdUMsWUFBQUEsR0FBRyxFQUFFLEtBRFA7QUFFRS9ILFlBQUFBLEdBQUcsRUFBRUE7QUFGUCxXQURGLEVBS0UsMERBTEY7QUFPQSxpQkFBT2tGLEVBQUUsQ0FBQyxJQUFELEVBQU8sQ0FBQ2xGLEdBQUQsQ0FBUCxDQUFUO0FBQ0QsU0ExQ2tDLENBNENuQztBQUNBOzs7QUFDQTBHLFFBQUFBLEtBQUssR0FBRyxJQUFSO0FBQ0F4QixRQUFBQSxFQUFFO0FBQ0gsT0FuREg7QUFxREQsS0FyRUgsRUFzRUU7QUFDQSxLQUFDbEYsR0FBRCxFQUFhZ0ksYUFBYixLQUE4RTtBQUM1RSwyQkFBTyxDQUFDaEksR0FBRCxJQUFRaUksS0FBSyxDQUFDQyxPQUFOLENBQWNGLGFBQWQsQ0FBZixFQUQ0RSxDQUc1RTtBQUNBOztBQUNBLFVBQUksQ0FBQ3RCLEtBQUwsRUFBWTtBQUNWLFlBQUl5QixrQkFBSjs7QUFDQSxhQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdKLGFBQWEsQ0FBQ3hCLE1BQWxDLEVBQTBDNEIsQ0FBQyxFQUEzQyxFQUErQztBQUM3QyxjQUFJSixhQUFhLENBQUNJLENBQUQsQ0FBakIsRUFBc0I7QUFDcEIsaUJBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0wsYUFBYSxDQUFDSSxDQUFELENBQWIsQ0FBaUI1QixNQUFyQyxFQUE2QzZCLENBQUMsRUFBOUMsRUFBa0Q7QUFDaEQsa0JBQUlMLGFBQWEsQ0FBQ0ksQ0FBRCxDQUFiLENBQWlCQyxDQUFqQixDQUFKLEVBQXlCO0FBQ3ZCLHNCQUFNQyxJQUFJLEdBQUdOLGFBQWEsQ0FBQ0ksQ0FBRCxDQUFiLENBQWlCQyxDQUFqQixFQUFvQkMsSUFBakM7O0FBQ0Esb0JBQUlBLElBQUksS0FBSyxXQUFULElBQXdCQSxJQUFJLEtBQUssaUJBQWpDLElBQXNEQSxJQUFJLEtBQUssWUFBbkUsRUFBaUY7QUFDL0VILGtCQUFBQSxrQkFBa0IsR0FBRyxJQUFyQjtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxZQUFJQSxrQkFBSixFQUF3QjtBQUN0QixpQkFBT3ZJLFFBQVEsQ0FBQ2lJLGlCQUFVVSxxQkFBVixFQUFELEVBQW9DLElBQXBDLEVBQTBDUCxhQUExQyxDQUFmO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQU9wSSxRQUFRLENBQUNpSSxpQkFBVVcsV0FBVixDQUFzQkMscUJBQVVDLFVBQWhDLENBQUQsRUFBOEMsSUFBOUMsRUFBb0RWLGFBQXBELENBQWY7QUFDRDtBQUNGOztBQUVELFVBQUlyQixPQUFPLENBQUNILE1BQVIsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsZUFBTzVHLFFBQVEsQ0FBQyxJQUFELEVBQU82RyxXQUFQLENBQWY7QUFDRDs7QUFFRDVFLE1BQUFBLElBQUksQ0FBQ3hDLFlBQUwsQ0FBa0JzSixjQUFsQixDQUNFakosSUFERixFQUVFK0csV0FGRixFQUdFLE9BQU96RyxHQUFQLEVBQVk0SSxnQkFBWixLQUF3RDtBQUN0RCxZQUFJNUksR0FBSixFQUFTO0FBQ1AsaUJBQU9KLFFBQVEsQ0FBQ0ksR0FBRCxDQUFmO0FBQ0QsU0FIcUQsQ0FJdEQ7QUFDQTs7O0FBQ0EsY0FBTTZJLFlBQXFCLEdBQUcsRUFBOUIsQ0FOc0QsQ0FPdEQ7O0FBQ0EsYUFBSyxNQUFNdkksTUFBWCxJQUFxQnVCLElBQUksQ0FBQ3pDLE9BQTFCLEVBQW1DO0FBQ2pDLGNBQUk7QUFDRjtBQUNBO0FBQ0F3SixZQUFBQSxnQkFBZ0IsR0FBRyxNQUFNdEksTUFBTSxDQUFDd0ksZUFBUCxDQUF1QkYsZ0JBQXZCLENBQXpCO0FBQ0QsV0FKRCxDQUlFLE9BQU81SSxHQUFQLEVBQVk7QUFDWjZJLFlBQUFBLFlBQVksQ0FBQ3ZDLElBQWIsQ0FBa0J0RyxHQUFsQjtBQUNEO0FBQ0Y7O0FBQ0RKLFFBQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU9nSixnQkFBUCxFQUF5QjFJLGdCQUFFNkksTUFBRixDQUFTZixhQUFULEVBQXdCYSxZQUF4QixDQUF6QixDQUFSO0FBQ0QsT0FyQkg7QUF1QkQsS0E5SEg7QUFnSUQ7QUFFRDs7Ozs7Ozs7QUFNT0csRUFBQUEsMkJBQVAsQ0FBbUM5QyxRQUFuQyxFQUF1RFksTUFBdkQsRUFBNkU7QUFDM0UsU0FBSyxNQUFNc0IsQ0FBWCxJQUFnQmxDLFFBQWhCLEVBQTBCO0FBQ3hCLFVBQUluQixNQUFNLENBQUNrRSxTQUFQLENBQWlCQyxjQUFqQixDQUFnQ0MsSUFBaEMsQ0FBcUNqRCxRQUFyQyxFQUErQ2tDLENBQS9DLENBQUosRUFBdUQ7QUFDckQsY0FBTXZILE9BQU8sR0FBR3FGLFFBQVEsQ0FBQ2tDLENBQUQsQ0FBeEIsQ0FEcUQsQ0FHckQ7QUFDQTs7QUFDQXZILFFBQUFBLE9BQU8sQ0FBQ3VJLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLG9CQUFYLENBQUQsQ0FBUCxHQUE0Q3ZDLE1BQU0sQ0FBQ0ssTUFBbkQ7QUFDRDtBQUNGO0FBQ0Y7O0FBM2tCc0M7O2VBOGtCMUJySSxPIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBhc3luYywgeyBBc3luY1Jlc3VsdEFycmF5Q2FsbGJhY2sgfSBmcm9tICdhc3luYyc7XG5pbXBvcnQgU3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgUHJveHlTdG9yYWdlIGZyb20gJy4vdXAtc3RvcmFnZSc7XG5pbXBvcnQgU2VhcmNoIGZyb20gJy4vc2VhcmNoJztcbmltcG9ydCB7IEFQSV9FUlJPUiwgSFRUUF9TVEFUVVMsIERJU1RfVEFHUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBMb2NhbFN0b3JhZ2UgZnJvbSAnLi9sb2NhbC1zdG9yYWdlJztcbmltcG9ydCB7IFJlYWRUYXJiYWxsIH0gZnJvbSAnQHZlcmRhY2Npby9zdHJlYW1zJztcbmltcG9ydCB7IGNoZWNrUGFja2FnZUxvY2FsLCBwdWJsaXNoUGFja2FnZSwgY2hlY2tQYWNrYWdlUmVtb3RlLCBjbGVhblVwTGlua3NSZWYsIG1lcmdlVXBsaW5rVGltZUludG9Mb2NhbCwgZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUgfSBmcm9tICcuL3N0b3JhZ2UtdXRpbHMnO1xuaW1wb3J0IHsgc2V0dXBVcExpbmtzLCB1cGRhdGVWZXJzaW9uc0hpZGRlblVwTGluayB9IGZyb20gJy4vdXBsaW5rLXV0aWwnO1xuaW1wb3J0IHsgbWVyZ2VWZXJzaW9ucyB9IGZyb20gJy4vbWV0YWRhdGEtdXRpbHMnO1xuaW1wb3J0IHsgRXJyb3JDb2RlLCBub3JtYWxpemVEaXN0VGFncywgdmFsaWRhdGVNZXRhZGF0YSwgaXNPYmplY3QgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IElTdG9yYWdlLCBJUHJveHksIElTdG9yYWdlSGFuZGxlciwgUHJveHlMaXN0LCBTdHJpbmdWYWx1ZSwgSUdldFBhY2thZ2VPcHRpb25zLCBJU3luY1VwbGlua3MsIElQbHVnaW5GaWx0ZXJzIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHsgSVJlYWRUYXJiYWxsLCBJVXBsb2FkVGFyYmFsbCwgVmVyc2lvbnMsIFBhY2thZ2UsIENvbmZpZywgTWVyZ2VUYWdzLCBWZXJzaW9uLCBEaXN0RmlsZSwgQ2FsbGJhY2ssIExvZ2dlciB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgaGFzUHJveHlUbyB9IGZyb20gJy4vY29uZmlnLXV0aWxzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL2xpYi9sb2dnZXInO1xuaW1wb3J0IHsgR2VuZXJpY0JvZHksIFRva2VuRmlsdGVyLCBUb2tlbiB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgVmVyZGFjY2lvRXJyb3IgfSBmcm9tICdAdmVyZGFjY2lvL2NvbW1vbnMtYXBpJztcblxuY2xhc3MgU3RvcmFnZSBpbXBsZW1lbnRzIElTdG9yYWdlSGFuZGxlciB7XG4gIHB1YmxpYyBsb2NhbFN0b3JhZ2U6IElTdG9yYWdlO1xuICBwdWJsaWMgY29uZmlnOiBDb25maWc7XG4gIHB1YmxpYyBsb2dnZXI6IExvZ2dlcjtcbiAgcHVibGljIHVwbGlua3M6IFByb3h5TGlzdDtcbiAgcHVibGljIGZpbHRlcnM6IElQbHVnaW5GaWx0ZXJzO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihjb25maWc6IENvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudXBsaW5rcyA9IHNldHVwVXBMaW5rcyhjb25maWcpO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyLmNoaWxkKCk7XG4gICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMubG9jYWxTdG9yYWdlID0gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBpbml0KGNvbmZpZzogQ29uZmlnLCBmaWx0ZXJzOiBJUGx1Z2luRmlsdGVycyA9IFtdKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIHRoaXMubG9jYWxTdG9yYWdlID0gbmV3IExvY2FsU3RvcmFnZSh0aGlzLmNvbmZpZywgbG9nZ2VyKTtcblxuICAgIHJldHVybiB0aGlzLmxvY2FsU3RvcmFnZS5nZXRTZWNyZXQoY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgQWRkIGEge25hbWV9IHBhY2thZ2UgdG8gYSBzeXN0ZW1cbiAgIEZ1bmN0aW9uIGNoZWNrcyBpZiBwYWNrYWdlIHdpdGggdGhlIHNhbWUgbmFtZSBpcyBhdmFpbGFibGUgZnJvbSB1cGxpbmtzLlxuICAgSWYgaXQgaXNuJ3QsIHdlIGNyZWF0ZSBwYWNrYWdlIGxvY2FsbHlcbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsICh3cml0ZSkgJiYgdXBsaW5rc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGFkZFBhY2thZ2UobmFtZTogc3RyaW5nLCBtZXRhZGF0YTogYW55LCBjYWxsYmFjazogRnVuY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2hlY2tQYWNrYWdlTG9jYWwobmFtZSwgdGhpcy5sb2NhbFN0b3JhZ2UpO1xuICAgICAgYXdhaXQgY2hlY2tQYWNrYWdlUmVtb3RlKG5hbWUsIHRoaXMuX2lzQWxsb3dQdWJsaXNoT2ZmbGluZSgpLCB0aGlzLl9zeW5jVXBsaW5rc01ldGFkYXRhLmJpbmQodGhpcykpO1xuICAgICAgYXdhaXQgcHVibGlzaFBhY2thZ2UobmFtZSwgbWV0YWRhdGEsIHRoaXMubG9jYWxTdG9yYWdlIGFzIElTdG9yYWdlKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2lzQWxsb3dQdWJsaXNoT2ZmbGluZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuY29uZmlnLnB1Ymxpc2ggIT09ICd1bmRlZmluZWQnICYmIF8uaXNCb29sZWFuKHRoaXMuY29uZmlnLnB1Ymxpc2guYWxsb3dfb2ZmbGluZSkgJiYgdGhpcy5jb25maWcucHVibGlzaC5hbGxvd19vZmZsaW5lO1xuICB9XG5cbiAgcHVibGljIHJlYWRUb2tlbnMoZmlsdGVyOiBUb2tlbkZpbHRlcik6IFByb21pc2U8QXJyYXk8VG9rZW4+PiB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yYWdlLnJlYWRUb2tlbnMoZmlsdGVyKTtcbiAgfVxuXG4gIHB1YmxpYyBzYXZlVG9rZW4odG9rZW46IFRva2VuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdG9yYWdlLnNhdmVUb2tlbih0b2tlbik7XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlVG9rZW4odXNlcjogc3RyaW5nLCB0b2tlbktleTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuZGVsZXRlVG9rZW4odXNlciwgdG9rZW5LZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyB2ZXJzaW9uIG9mIHBhY2thZ2Uge25hbWV9IHRvIGEgc3lzdGVtXG4gICBVc2VkIHN0b3JhZ2VzOiBsb2NhbCAod3JpdGUpXG4gICAqL1xuICBwdWJsaWMgYWRkVmVyc2lvbihuYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZywgbWV0YWRhdGE6IFZlcnNpb24sIHRhZzogU3RyaW5nVmFsdWUsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLmFkZFZlcnNpb24obmFtZSwgdmVyc2lvbiwgbWV0YWRhdGEsIHRhZywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFRhZ3MgYSBwYWNrYWdlIHZlcnNpb24gd2l0aCBhIHByb3ZpZGVkIHRhZ1xuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIG1lcmdlVGFncyhuYW1lOiBzdHJpbmcsIHRhZ0hhc2g6IE1lcmdlVGFncywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UubWVyZ2VUYWdzKG5hbWUsIHRhZ0hhc2gsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgYW4gZXhpc3RpbmcgcGFja2FnZSAoaS5lLiB1bnB1Ymxpc2ggb25lIHZlcnNpb24pXG4gICBGdW5jdGlvbiBjaGFuZ2VzIGEgcGFja2FnZSBpbmZvIGZyb20gbG9jYWwgc3RvcmFnZSBhbmQgYWxsIHVwbGlua3Mgd2l0aCB3cml0ZSBhY2Nlc3MuL1xuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIGNoYW5nZVBhY2thZ2UobmFtZTogc3RyaW5nLCBtZXRhZGF0YTogUGFja2FnZSwgcmV2aXNpb246IHN0cmluZywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UuY2hhbmdlUGFja2FnZShuYW1lLCBtZXRhZGF0YSwgcmV2aXNpb24sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBwYWNrYWdlIGZyb20gYSBzeXN0ZW1cbiAgIEZ1bmN0aW9uIHJlbW92ZXMgYSBwYWNrYWdlIGZyb20gbG9jYWwgc3RvcmFnZVxuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgKHdyaXRlKVxuICAgKi9cbiAgcHVibGljIHJlbW92ZVBhY2thZ2UobmFtZTogc3RyaW5nLCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVQYWNrYWdlKG5hbWUsIGNhbGxiYWNrKTtcbiAgICAvLyB1cGRhdGUgdGhlIGluZGV4ZXJcbiAgICBTZWFyY2gucmVtb3ZlKG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICBSZW1vdmUgYSB0YXJiYWxsIGZyb20gYSBzeXN0ZW1cbiAgIEZ1bmN0aW9uIHJlbW92ZXMgYSB0YXJiYWxsIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAgIFRhcmJhbGwgaW4gcXVlc3Rpb24gc2hvdWxkIG5vdCBiZSBsaW5rZWQgdG8gaW4gYW55IGV4aXN0aW5nXG4gICB2ZXJzaW9ucywgaS5lLiBwYWNrYWdlIHZlcnNpb24gc2hvdWxkIGJlIHVucHVibGlzaGVkIGZpcnN0LlxuICAgVXNlZCBzdG9yYWdlOiBsb2NhbCAod3JpdGUpXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlVGFyYmFsbChuYW1lOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcsIHJldmlzaW9uOiBzdHJpbmcsIGNhbGxiYWNrOiBDYWxsYmFjayk6IHZvaWQge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLnJlbW92ZVRhcmJhbGwobmFtZSwgZmlsZW5hbWUsIHJldmlzaW9uLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogVXBsb2FkIGEgdGFyYmFsbCBmb3Ige25hbWV9IHBhY2thZ2VcbiAgIEZ1bmN0aW9uIGlzIHN5bmNocm9ub3VzIGFuZCByZXR1cm5zIGEgV3JpdGFibGVTdHJlYW1cbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsICh3cml0ZSlcbiAgICovXG4gIHB1YmxpYyBhZGRUYXJiYWxsKG5hbWU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IElVcGxvYWRUYXJiYWxsIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuYWRkVGFyYmFsbChuYW1lLCBmaWxlbmFtZSk7XG4gIH1cblxuICAvKipcbiAgIEdldCBhIHRhcmJhbGwgZnJvbSBhIHN0b3JhZ2UgZm9yIHtuYW1lfSBwYWNrYWdlXG4gICBGdW5jdGlvbiBpcyBzeW5jaHJvbm91cyBhbmQgcmV0dXJucyBhIFJlYWRhYmxlU3RyZWFtXG4gICBGdW5jdGlvbiB0cmllcyB0byByZWFkIHRhcmJhbGwgbG9jYWxseSwgaWYgaXQgZmFpbHMgdGhlbiBpdCByZWFkcyBwYWNrYWdlXG4gICBpbmZvcm1hdGlvbiBpbiBvcmRlciB0byBmaWd1cmUgb3V0IHdoZXJlIHdlIGNhbiBnZXQgdGhpcyB0YXJiYWxsIGZyb21cbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsIHx8IHVwbGluayAoanVzdCBvbmUpXG4gICAqL1xuICBwdWJsaWMgZ2V0VGFyYmFsbChuYW1lOiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpOiBJUmVhZFRhcmJhbGwge1xuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSBuZXcgUmVhZFRhcmJhbGwoe30pO1xuICAgIHJlYWRTdHJlYW0uYWJvcnQgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBpZiBzb21lb25lIHJlcXVlc3RpbmcgdGFyYmFsbCwgaXQgbWVhbnMgdGhhdCB3ZSBzaG91bGQgYWxyZWFkeSBoYXZlIHNvbWVcbiAgICAvLyBpbmZvcm1hdGlvbiBhYm91dCBpdCwgc28gZmV0Y2hpbmcgcGFja2FnZSBpbmZvIGlzIHVubmVjZXNzYXJ5XG5cbiAgICAvLyB0cnlpbmcgbG9jYWwgZmlyc3RcbiAgICAvLyBmbG93OiBzaG91bGQgYmUgSVJlYWRUYXJiYWxsXG4gICAgbGV0IGxvY2FsU3RyZWFtOiBhbnkgPSBzZWxmLmxvY2FsU3RvcmFnZS5nZXRUYXJiYWxsKG5hbWUsIGZpbGVuYW1lKTtcbiAgICBsZXQgaXNPcGVuID0gZmFsc2U7XG4gICAgbG9jYWxTdHJlYW0ub24oXG4gICAgICAnZXJyb3InLFxuICAgICAgKGVycik6IGFueSA9PiB7XG4gICAgICAgIGlmIChpc09wZW4gfHwgZXJyLnN0YXR1cyAhPT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG9jYWwgcmVwb3J0ZWQgNDA0XG4gICAgICAgIGNvbnN0IGVycjQwNCA9IGVycjtcbiAgICAgICAgbG9jYWxTdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgbG9jYWxTdHJlYW0gPSBudWxsOyAvLyB3ZSBmb3JjZSBmb3IgZ2FyYmFnZSBjb2xsZWN0b3JcbiAgICAgICAgc2VsZi5sb2NhbFN0b3JhZ2UuZ2V0UGFja2FnZU1ldGFkYXRhKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgKGVyciwgaW5mbzogUGFja2FnZSk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgaWYgKF8uaXNOaWwoZXJyKSAmJiBpbmZvLl9kaXN0ZmlsZXMgJiYgXy5pc05pbChpbmZvLl9kaXN0ZmlsZXNbZmlsZW5hbWVdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBmaWxlIGV4aXN0cyBsb2NhbGx5XG4gICAgICAgICAgICAgIHNlcnZlRmlsZShpbmZvLl9kaXN0ZmlsZXNbZmlsZW5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHdlIGtub3cgbm90aGluZyBhYm91dCB0aGlzIGZpbGUsIHRyeWluZyB0byBnZXQgaW5mb3JtYXRpb24gZWxzZXdoZXJlXG4gICAgICAgICAgICAgIHNlbGYuX3N5bmNVcGxpbmtzTWV0YWRhdGEoXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBpbmZvLFxuICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgIChlcnIsIGluZm86IFBhY2thZ2UpOiBhbnkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKF8uaXNOaWwoZXJyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKF8uaXNOaWwoaW5mby5fZGlzdGZpbGVzKSB8fCBfLmlzTmlsKGluZm8uX2Rpc3RmaWxlc1tmaWxlbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkU3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyNDA0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHNlcnZlRmlsZShpbmZvLl9kaXN0ZmlsZXNbZmlsZW5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG4gICAgbG9jYWxTdHJlYW0ub24oJ2NvbnRlbnQtbGVuZ3RoJywgZnVuY3Rpb24odik6IHZvaWQge1xuICAgICAgcmVhZFN0cmVhbS5lbWl0KCdjb250ZW50LWxlbmd0aCcsIHYpO1xuICAgIH0pO1xuICAgIGxvY2FsU3RyZWFtLm9uKCdvcGVuJywgZnVuY3Rpb24oKTogdm9pZCB7XG4gICAgICBpc09wZW4gPSB0cnVlO1xuICAgICAgbG9jYWxTdHJlYW0ucGlwZShyZWFkU3RyZWFtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVhZFN0cmVhbTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoIGFuZCBjYWNoZSBsb2NhbC9yZW1vdGUgcGFja2FnZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZpbGUgZGVmaW5lIHRoZSBwYWNrYWdlIHNoYXBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VydmVGaWxlKGZpbGU6IERpc3RGaWxlKTogdm9pZCB7XG4gICAgICBsZXQgdXBsaW5rOiBhbnkgPSBudWxsO1xuXG4gICAgICBmb3IgKGNvbnN0IHVwbGlua0lkIGluIHNlbGYudXBsaW5rcykge1xuICAgICAgICBpZiAoc2VsZi51cGxpbmtzW3VwbGlua0lkXS5pc1VwbGlua1ZhbGlkKGZpbGUudXJsKSkge1xuICAgICAgICAgIHVwbGluayA9IHNlbGYudXBsaW5rc1t1cGxpbmtJZF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHVwbGluayA9PSBudWxsKSB7XG4gICAgICAgIHVwbGluayA9IG5ldyBQcm94eVN0b3JhZ2UoXG4gICAgICAgICAge1xuICAgICAgICAgICAgdXJsOiBmaWxlLnVybCxcbiAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICAgICAgX2F1dG9nZW5lcmF0ZWQ6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZWxmLmNvbmZpZ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2F2ZXN0cmVhbTogSVVwbG9hZFRhcmJhbGwgfCBudWxsID0gbnVsbDtcbiAgICAgIGlmICh1cGxpbmsuY29uZmlnLmNhY2hlKSB7XG4gICAgICAgIHNhdmVzdHJlYW0gPSBzZWxmLmxvY2FsU3RvcmFnZS5hZGRUYXJiYWxsKG5hbWUsIGZpbGVuYW1lKTtcbiAgICAgIH1cblxuICAgICAgbGV0IG9uX29wZW4gPSBmdW5jdGlvbigpOiB2b2lkIHtcbiAgICAgICAgLy8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNhbGxlZCB0d2ljZVxuICAgICAgICBvbl9vcGVuID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgY29uc3QgcnN0cmVhbTIgPSB1cGxpbmsuZmV0Y2hUYXJiYWxsKGZpbGUudXJsKTtcbiAgICAgICAgcnN0cmVhbTIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKTogdm9pZCB7XG4gICAgICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgICAgIHNhdmVzdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2F2ZXN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgcmVhZFN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByc3RyZWFtMi5vbignZW5kJywgZnVuY3Rpb24oKTogdm9pZCB7XG4gICAgICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgICAgIHNhdmVzdHJlYW0uZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcnN0cmVhbTIub24oJ2NvbnRlbnQtbGVuZ3RoJywgZnVuY3Rpb24odik6IHZvaWQge1xuICAgICAgICAgIHJlYWRTdHJlYW0uZW1pdCgnY29udGVudC1sZW5ndGgnLCB2KTtcbiAgICAgICAgICBpZiAoc2F2ZXN0cmVhbSkge1xuICAgICAgICAgICAgc2F2ZXN0cmVhbS5lbWl0KCdjb250ZW50LWxlbmd0aCcsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJzdHJlYW0yLnBpcGUocmVhZFN0cmVhbSk7XG4gICAgICAgIGlmIChzYXZlc3RyZWFtKSB7XG4gICAgICAgICAgcnN0cmVhbTIucGlwZShzYXZlc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKHNhdmVzdHJlYW0pIHtcbiAgICAgICAgc2F2ZXN0cmVhbS5vbignb3BlbicsIGZ1bmN0aW9uKCk6IHZvaWQge1xuICAgICAgICAgIG9uX29wZW4oKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2F2ZXN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpOiB2b2lkIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci53YXJuKHsgZXJyOiBlcnIsIGZpbGVOYW1lOiBmaWxlIH0sICdlcnJvciBzYXZpbmcgZmlsZSBAe2ZpbGVOYW1lfTogQHtlcnIubWVzc2FnZX1cXG5Ae2Vyci5zdGFja30nKTtcbiAgICAgICAgICBpZiAoc2F2ZXN0cmVhbSkge1xuICAgICAgICAgICAgc2F2ZXN0cmVhbS5hYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzYXZlc3RyZWFtID0gbnVsbDtcbiAgICAgICAgICBvbl9vcGVuKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25fb3BlbigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgUmV0cmlldmUgYSBwYWNrYWdlIG1ldGFkYXRhIGZvciB7bmFtZX0gcGFja2FnZVxuICAgRnVuY3Rpb24gaW52b2tlcyBsb2NhbFN0b3JhZ2UuZ2V0UGFja2FnZSBhbmQgdXBsaW5rLmdldF9wYWNrYWdlIGZvciBldmVyeVxuICAgdXBsaW5rIHdpdGggcHJveHlfYWNjZXNzIHJpZ2h0cyBhZ2FpbnN0IHtuYW1lfSBhbmQgY29tYmluZXMgcmVzdWx0c1xuICAgaW50byBvbmUganNvbiBvYmplY3RcbiAgIFVzZWQgc3RvcmFnZXM6IGxvY2FsICYmIHVwbGluayAocHJveHlfYWNjZXNzKVxuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcHRpb25zLm5hbWUgUGFja2FnZSBOYW1lXG4gICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAgb3B0aW9ucy5yZXEgRXhwcmVzcyBgcmVxYCBvYmplY3RcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBvcHRpb25zLmtlZXBVcExpbmtEYXRhIGtlZXAgdXAgbGluayBpbmZvIGluIHBhY2thZ2UgbWV0YSwgbGFzdCB1cGRhdGUsIGV0Yy5cbiAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gb3B0aW9ucy5jYWxsYmFjayBDYWxsYmFjayBmb3IgcmVjZWl2ZSBkYXRhXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFja2FnZShvcHRpb25zOiBJR2V0UGFja2FnZU9wdGlvbnMpOiB2b2lkIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5nZXRQYWNrYWdlTWV0YWRhdGEoXG4gICAgICBvcHRpb25zLm5hbWUsXG4gICAgICAoZXJyLCBkYXRhKTogdm9pZCA9PiB7XG4gICAgICAgIGlmIChlcnIgJiYgKCFlcnIuc3RhdHVzIHx8IGVyci5zdGF0dXMgPj0gSFRUUF9TVEFUVVMuSU5URVJOQUxfRVJST1IpKSB7XG4gICAgICAgICAgLy8gcmVwb3J0IGludGVybmFsIGVycm9ycyByaWdodCBhd2F5XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N5bmNVcGxpbmtzTWV0YWRhdGEob3B0aW9ucy5uYW1lLCBkYXRhLCB7IHJlcTogb3B0aW9ucy5yZXEsIHVwbGlua3NMb29rOiBvcHRpb25zLnVwbGlua3NMb29rIH0sIGZ1bmN0aW9uIGdldFBhY2thZ2VTeW5VcExpbmtzQ2FsbGJhY2soXG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIHJlc3VsdDogUGFja2FnZSxcbiAgICAgICAgICB1cGxpbmtFcnJvcnNcbiAgICAgICAgKTogdm9pZCB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub3JtYWxpemVEaXN0VGFncyhjbGVhblVwTGlua3NSZWYob3B0aW9ucy5rZWVwVXBMaW5rRGF0YSwgcmVzdWx0KSk7XG5cbiAgICAgICAgICAvLyBucG0gY2FuIHRocm93IGlmIHRoaXMgZmllbGQgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHJlc3VsdC5fYXR0YWNobWVudHMgPSB7fTtcblxuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sobnVsbCwgcmVzdWx0LCB1cGxpbmtFcnJvcnMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICBSZXRyaWV2ZSByZW1vdGUgYW5kIGxvY2FsIHBhY2thZ2VzIG1vcmUgcmVjZW50IHRoYW4ge3N0YXJ0a2V5fVxuICAgRnVuY3Rpb24gc3RyZWFtcyBhbGwgcGFja2FnZXMgZnJvbSBhbGwgdXBsaW5rcyBmaXJzdCwgYW5kIHRoZW5cbiAgIGxvY2FsIHBhY2thZ2VzLlxuICAgTm90ZSB0aGF0IGxvY2FsIHBhY2thZ2VzIGNvdWxkIG92ZXJyaWRlIHJlZ2lzdHJ5IG9uZXMganVzdCBiZWNhdXNlXG4gICB0aGV5IGFwcGVhciBpbiBKU09OIGxhc3QuIFRoYXQncyBhIHRyYWRlLW9mZiB3ZSBtYWtlIHRvIGF2b2lkXG4gICBtZW1vcnkgaXNzdWVzLlxuICAgVXNlZCBzdG9yYWdlczogbG9jYWwgJiYgdXBsaW5rIChwcm94eV9hY2Nlc3MpXG4gICAqIEBwYXJhbSB7Kn0gc3RhcnRrZXlcbiAgICogQHBhcmFtIHsqfSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIHB1YmxpYyBzZWFyY2goc3RhcnRrZXk6IHN0cmluZywgb3B0aW9uczogYW55KTogSVJlYWRUYXJiYWxsIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAvLyBzdHJlYW0gdG8gd3JpdGUgYSB0YXJiYWxsXG4gICAgY29uc3Qgc3RyZWFtOiBhbnkgPSBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcblxuICAgIGFzeW5jLmVhY2hTZXJpZXMoXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnVwbGlua3MpLFxuICAgICAgZnVuY3Rpb24odXBfbmFtZSwgY2IpOiB2b2lkIHtcbiAgICAgICAgLy8gc2hvcnRjdXQ6IGlmIGBsb2NhbD0xYCBpcyBzdXBwbGllZCwgZG9uJ3QgY2FsbCB1cGxpbmtzXG4gICAgICAgIGlmIChvcHRpb25zLnJlcS5xdWVyeS5sb2NhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VhcmNoIGJ5IGtleXdvcmQgZm9yIGVhY2ggdXBsaW5rXG4gICAgICAgIGNvbnN0IGxzdHJlYW06IElVcGxvYWRUYXJiYWxsID0gc2VsZi51cGxpbmtzW3VwX25hbWVdLnNlYXJjaChvcHRpb25zKTtcbiAgICAgICAgLy8gam9pbiBzdHJlYW1zXG4gICAgICAgIGxzdHJlYW0ucGlwZShcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgeyBlbmQ6IGZhbHNlIH1cbiAgICAgICAgKTtcbiAgICAgICAgbHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpOiB2b2lkIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5lcnJvcih7IGVycjogZXJyIH0sICd1cGxpbmsgZXJyb3I6IEB7ZXJyLm1lc3NhZ2V9Jyk7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgICBjYiA9IGZ1bmN0aW9uKCk6IHZvaWQge307XG4gICAgICAgIH0pO1xuICAgICAgICBsc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpOiB2b2lkIHtcbiAgICAgICAgICBjYigpO1xuICAgICAgICAgIGNiID0gZnVuY3Rpb24oKTogdm9pZCB7fTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RyZWFtLmFib3J0ID0gZnVuY3Rpb24oKTogdm9pZCB7XG4gICAgICAgICAgaWYgKGxzdHJlYW0uYWJvcnQpIHtcbiAgICAgICAgICAgIGxzdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgICBjYiA9IGZ1bmN0aW9uKCk6IHZvaWQge307XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgLy8gZXhlY3V0ZWQgYWZ0ZXIgYWxsIHNlcmllc1xuICAgICAgZnVuY3Rpb24oKTogdm9pZCB7XG4gICAgICAgIC8vIGF0dGFjaCBhIGxvY2FsIHNlYXJjaCByZXN1bHRzXG4gICAgICAgIGNvbnN0IGxzdHJlYW06IElSZWFkVGFyYmFsbCA9IHNlbGYubG9jYWxTdG9yYWdlLnNlYXJjaChzdGFydGtleSwgb3B0aW9ucyk7XG4gICAgICAgIHN0cmVhbS5hYm9ydCA9IGZ1bmN0aW9uKCk6IHZvaWQge1xuICAgICAgICAgIGxzdHJlYW0uYWJvcnQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbHN0cmVhbS5waXBlKFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICB7IGVuZDogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICAgIGxzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyOiBWZXJkYWNjaW9FcnJvcik6IHZvaWQge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKHsgZXJyOiBlcnIgfSwgJ3NlYXJjaCBlcnJvcjogQHtlcnIubWVzc2FnZX0nKTtcbiAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIG9ubHkgcHJpdmF0ZSBsb2NhbCBwYWNrYWdlc1xuICAgKiBAcGFyYW0geyp9IGNhbGxiYWNrXG4gICAqL1xuICBwdWJsaWMgZ2V0TG9jYWxEYXRhYmFzZShjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5zdG9yYWdlUGx1Z2luLmdldChcbiAgICAgIChlcnIsIGxvY2Fscyk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhY2thZ2VzOiBWZXJzaW9uW10gPSBbXTtcbiAgICAgICAgY29uc3QgZ2V0UGFja2FnZSA9IGZ1bmN0aW9uKGl0ZW1Qa2cpOiB2b2lkIHtcbiAgICAgICAgICBzZWxmLmxvY2FsU3RvcmFnZS5nZXRQYWNrYWdlTWV0YWRhdGEobG9jYWxzW2l0ZW1Qa2ddLCBmdW5jdGlvbihlcnIsIHBrZ01ldGFkYXRhOiBQYWNrYWdlKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoXy5pc05pbChlcnIpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhdGVzdCA9IHBrZ01ldGFkYXRhW0RJU1RfVEFHU10ubGF0ZXN0O1xuICAgICAgICAgICAgICBpZiAobGF0ZXN0ICYmIHBrZ01ldGFkYXRhLnZlcnNpb25zW2xhdGVzdF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uOiBWZXJzaW9uID0gcGtnTWV0YWRhdGEudmVyc2lvbnNbbGF0ZXN0XTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lTGlzdCA9IHBrZ01ldGFkYXRhLnRpbWUgYXMgR2VuZXJpY0JvZHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IHRpbWVMaXN0W2xhdGVzdF07XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHZlcnNpb24udGltZSA9IHRpbWU7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgZm9yIHN0YXJzIGFwaVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB2ZXJzaW9uLnVzZXJzID0gcGtnTWV0YWRhdGEudXNlcnM7XG5cbiAgICAgICAgICAgICAgICBwYWNrYWdlcy5wdXNoKHZlcnNpb24pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4oeyBwYWNrYWdlOiBsb2NhbHNbaXRlbVBrZ10gfSwgJ3BhY2thZ2UgQHtwYWNrYWdlfSBkb2VzIG5vdCBoYXZlIGEgXCJsYXRlc3RcIiB0YWc/Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGl0ZW1Qa2cgPj0gbG9jYWxzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcGFja2FnZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ2V0UGFja2FnZShpdGVtUGtnICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGxvY2Fscy5sZW5ndGgpIHtcbiAgICAgICAgICBnZXRQYWNrYWdlKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gZmV0Y2hlcyBwYWNrYWdlIG1ldGFkYXRhIGZyb20gdXBsaW5rcyBhbmQgc3luY2hyb25pemVzIGl0IHdpdGggbG9jYWwgZGF0YVxuICAgaWYgcGFja2FnZSBpcyBhdmFpbGFibGUgbG9jYWxseSwgaXQgTVVTVCBiZSBwcm92aWRlZCBpbiBwa2dpbmZvXG4gICByZXR1cm5zIGNhbGxiYWNrKGVyciwgcmVzdWx0LCB1cGxpbmtfZXJyb3JzKVxuICAgKi9cbiAgcHVibGljIF9zeW5jVXBsaW5rc01ldGFkYXRhKG5hbWU6IHN0cmluZywgcGFja2FnZUluZm86IFBhY2thZ2UsIG9wdGlvbnM6IElTeW5jVXBsaW5rcywgY2FsbGJhY2s6IENhbGxiYWNrKTogdm9pZCB7XG4gICAgbGV0IGZvdW5kID0gdHJ1ZTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCB1cExpbmtzOiBJUHJveHlbXSA9IFtdO1xuICAgIGNvbnN0IGhhc1RvTG9va0ludG9VcGxpbmtzID0gXy5pc05pbChvcHRpb25zLnVwbGlua3NMb29rKSB8fCBvcHRpb25zLnVwbGlua3NMb29rO1xuXG4gICAgaWYgKCFwYWNrYWdlSW5mbykge1xuICAgICAgZm91bmQgPSBmYWxzZTtcbiAgICAgIHBhY2thZ2VJbmZvID0gZ2VuZXJhdGVQYWNrYWdlVGVtcGxhdGUobmFtZSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1cGxpbmsgaW4gdGhpcy51cGxpbmtzKSB7XG4gICAgICBpZiAoaGFzUHJveHlUbyhuYW1lLCB1cGxpbmssIHRoaXMuY29uZmlnLnBhY2thZ2VzKSAmJiBoYXNUb0xvb2tJbnRvVXBsaW5rcykge1xuICAgICAgICB1cExpbmtzLnB1c2godGhpcy51cGxpbmtzW3VwbGlua10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLm1hcChcbiAgICAgIHVwTGlua3MsXG4gICAgICAodXBMaW5rLCBjYik6IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB1cExpbmtNZXRhID0gcGFja2FnZUluZm8uX3VwbGlua3NbdXBMaW5rLnVwbmFtZV07XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KHVwTGlua01ldGEpKSB7XG4gICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IHVwTGlua01ldGEuZmV0Y2hlZDtcblxuICAgICAgICAgIGlmIChmZXRjaGVkICYmIERhdGUubm93KCkgLSBmZXRjaGVkIDwgdXBMaW5rLm1heGFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX29wdGlvbnMuZXRhZyA9IHVwTGlua01ldGEuZXRhZztcbiAgICAgICAgfVxuXG4gICAgICAgIHVwTGluay5nZXRSZW1vdGVNZXRhZGF0YShcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIF9vcHRpb25zLFxuICAgICAgICAgIChlcnIsIHVwTGlua1Jlc3BvbnNlLCBlVGFnKTogdm9pZCA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyci5yZW1vdGVTdGF0dXMgPT09IDMwNCkge1xuICAgICAgICAgICAgICB1cExpbmtNZXRhLmZldGNoZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyIHx8ICF1cExpbmtSZXNwb25zZSkge1xuICAgICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgW2VyciB8fCBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcignbm8gZGF0YScpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlTWV0YWRhdGEodXBMaW5rUmVzcG9uc2UsIG5hbWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN1YjogJ291dCcsXG4gICAgICAgICAgICAgICAgICBlcnI6IGVycixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYWNrYWdlLmpzb24gdmFsaWRhdGluZyBlcnJvciBAeyFlcnIubWVzc2FnZX1cXG5Ae2Vyci5zdGFja30nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBbZXJyXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhY2thZ2VJbmZvLl91cGxpbmtzW3VwTGluay51cG5hbWVdID0ge1xuICAgICAgICAgICAgICBldGFnOiBlVGFnLFxuICAgICAgICAgICAgICBmZXRjaGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcGFja2FnZUluZm8udGltZSA9IG1lcmdlVXBsaW5rVGltZUludG9Mb2NhbChwYWNrYWdlSW5mbywgdXBMaW5rUmVzcG9uc2UpO1xuXG4gICAgICAgICAgICB1cGRhdGVWZXJzaW9uc0hpZGRlblVwTGluayh1cExpbmtSZXNwb25zZS52ZXJzaW9ucywgdXBMaW5rKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbWVyZ2VWZXJzaW9ucyhwYWNrYWdlSW5mbywgdXBMaW5rUmVzcG9uc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHNlbGYubG9nZ2VyLmVycm9yKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN1YjogJ291dCcsXG4gICAgICAgICAgICAgICAgICBlcnI6IGVycixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYWNrYWdlLmpzb24gcGFyc2luZyBlcnJvciBAeyFlcnIubWVzc2FnZX1cXG5Ae2Vyci5zdGFja30nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBbZXJyXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGdvdCB0byB0aGlzIHBvaW50LCBhc3N1bWUgdGhhdCB0aGUgY29ycmVjdCBwYWNrYWdlIGV4aXN0c1xuICAgICAgICAgICAgLy8gb24gdGhlIHVwbGlua1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgKGVycjogRXJyb3IsIHVwTGlua3NFcnJvcnM6IGFueSk6IEFzeW5jUmVzdWx0QXJyYXlDYWxsYmFjazx1bmtub3duLCBFcnJvcj4gPT4ge1xuICAgICAgICBhc3NlcnQoIWVyciAmJiBBcnJheS5pc0FycmF5KHVwTGlua3NFcnJvcnMpKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgY29ubmVjdGlvbiB0aW1lb3V0IG9yIHJlc2V0IGVycm9ycyB3aXRoIHVwbGluayhzKVxuICAgICAgICAvLyAodGhlc2Ugc2hvdWxkIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkgZnJvbSB0aGUgcGFja2FnZSBub3QgYmVpbmcgZm91bmQpXG4gICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICBsZXQgdXBsaW5rVGltZW91dEVycm9yO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXBMaW5rc0Vycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHVwTGlua3NFcnJvcnNbaV0pIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB1cExpbmtzRXJyb3JzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVwTGlua3NFcnJvcnNbaV1bal0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB1cExpbmtzRXJyb3JzW2ldW2pdLmNvZGU7XG4gICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gJ0VUSU1FRE9VVCcgfHwgY29kZSA9PT0gJ0VTT0NLRVRUSU1FRE9VVCcgfHwgY29kZSA9PT0gJ0VDT05OUkVTRVQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbGlua1RpbWVvdXRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1cGxpbmtUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFcnJvckNvZGUuZ2V0U2VydmljZVVuYXZhaWxhYmxlKCksIG51bGwsIHVwTGlua3NFcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soRXJyb3JDb2RlLmdldE5vdEZvdW5kKEFQSV9FUlJPUi5OT19QQUNLQUdFKSwgbnVsbCwgdXBMaW5rc0Vycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwTGlua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHBhY2thZ2VJbmZvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYubG9jYWxTdG9yYWdlLnVwZGF0ZVZlcnNpb25zKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcGFja2FnZUluZm8sXG4gICAgICAgICAgYXN5bmMgKGVyciwgcGFja2FnZUpzb25Mb2NhbDogUGFja2FnZSk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW55IGVycm9yIGhlcmUgd2lsbCBjYXVzZSBhIDQwNCwgbGlrZSBhbiB1cGxpbmsgZXJyb3IuIFRoaXMgaXMgbGlrZWx5IHRoZSByaWdodCB0aGluZyB0byBkb1xuICAgICAgICAgICAgLy8gYXMgYSBicm9rZW4gZmlsdGVyIGlzIGEgc2VjdXJpdHkgcmlzay5cbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckVycm9yczogRXJyb3JbXSA9IFtdO1xuICAgICAgICAgICAgLy8gVGhpcyBNVVNUIGJlIGRvbmUgc2VyaWFsbHkgYW5kIG5vdCBpbiBwYXJhbGxlbCBhcyB0aGV5IG1vZGlmeSBwYWNrYWdlSnNvbkxvY2FsXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBzZWxmLmZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBmaWx0ZXJzIGNhbiBhc3N1bWUgaXQncyBzYXZlIHRvIG1vZGlmeSBwYWNrYWdlSnNvbkxvY2FsIGFuZCByZXR1cm4gaXQgZGlyZWN0bHkgZm9yXG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybWFuY2UgKGkuZS4gbmVlZCBub3QgYmUgcHVyZSlcbiAgICAgICAgICAgICAgICBwYWNrYWdlSnNvbkxvY2FsID0gYXdhaXQgZmlsdGVyLmZpbHRlcl9tZXRhZGF0YShwYWNrYWdlSnNvbkxvY2FsKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcGFja2FnZUpzb25Mb2NhbCwgXy5jb25jYXQodXBMaW5rc0Vycm9ycywgZmlsdGVyRXJyb3JzKSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgaGlkZGVuIHZhbHVlIGZvciBlYWNoIHZlcnNpb24uXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZlcnNpb25zIGxpc3Qgb2YgdmVyc2lvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXBMaW5rIHVwbGluayBuYW1lXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwdWJsaWMgX3VwZGF0ZVZlcnNpb25zSGlkZGVuVXBMaW5rKHZlcnNpb25zOiBWZXJzaW9ucywgdXBMaW5rOiBJUHJveHkpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdmVyc2lvbnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmVyc2lvbnMsIGkpKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uc1tpXTtcblxuICAgICAgICAvLyBob2xkcyBhIFwiaGlkZGVuXCIgdmFsdWUgdG8gYmUgdXNlZCBieSB0aGUgcGFja2FnZSBzdG9yYWdlLlxuICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIHZlcnNpb25bU3ltYm9sLmZvcignX192ZXJkYWNjaW9fdXBsaW5rJyldID0gdXBMaW5rLnVwbmFtZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RvcmFnZTtcbiJdfQ==