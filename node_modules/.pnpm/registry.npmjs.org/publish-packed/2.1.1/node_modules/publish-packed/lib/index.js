"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const rimraf = require("rimraf-then");
const renameKeys_1 = require("./renameKeys");
const readPkg = require("read-pkg");
const renameOverwrite = require("rename-overwrite");
const nmPrune = require("nm-prune");
const runNpm_1 = require("./runNpm");
function default_1(pkgDir, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        opts = opts || {};
        const tag = opts.tag || 'latest';
        const prune = opts.prune || false;
        const modules = path.join(pkgDir, 'node_modules');
        const tmpModules = path.join(pkgDir, 'tmp_node_modules');
        let publishedModules = null;
        yield runPrepublishScript(pkgDir);
        try {
            yield renameOverwriteIfExists(modules, tmpModules);
            yield runNpm_1.default(['install', '--production', '--ignore-scripts', '--no-package-lock'], pkgDir);
            if (prune)
                yield pruneNodeModules(pkgDir);
            publishedModules = path.join(pkgDir, 'lib', 'node_modules');
            yield renameOverwrite(modules, publishedModules);
            yield hideDeps(pkgDir);
            yield runNpm_1.default(['publish', '--tag', tag], pkgDir);
        }
        finally {
            yield unhideDeps(pkgDir);
            yield renameOverwriteIfExists(tmpModules, modules);
            if (publishedModules)
                yield rimraf(publishedModules);
        }
    });
}
exports.default = default_1;
function pruneNodeModules(pkgDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const info = yield nmPrune.prep(pkgDir, { pruneLicense: false });
        yield Promise.all(info.files.map(fullPath => fs.remove(fullPath)));
        yield Promise.all(info.dirs.map(fullPath => fs.remove(fullPath)));
    });
}
function renameOverwriteIfExists(oldPath, newPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield renameOverwrite(oldPath, newPath);
        }
        catch (err) {
            if (err['code'] !== 'ENOENT')
                throw err;
        }
    });
}
function runPrepublishScript(pkgDir) {
    return __awaiter(this, void 0, void 0, function* () {
        const pkgJson = yield readPkg({ cwd: pkgDir });
        if (!pkgJson['scripts'])
            return;
        if (pkgJson['scripts']['prepublish']) {
            yield runNpm_1.default(['run', 'prepublish'], pkgDir);
        }
        if (pkgJson['scripts']['prepublishOnly']) {
            yield runNpm_1.default(['run', 'prepublishOnly'], pkgDir);
        }
    });
}
function hideDeps(pkgDir) {
    return renameKeys_1.default(pkgDir, {
        dependencies: '__dependencies',
        devDependencies: '__devDependencies',
        optionalDependencies: '__optionalDependencies',
        scripts: {
            prepublish: '__prepublish',
            prepublishOnly: '__prepublishOnly'
        }
    });
}
function unhideDeps(pkgDir) {
    return renameKeys_1.default(pkgDir, {
        __dependencies: 'dependencies',
        __devDependencies: 'devDependencies',
        __optionalDependencies: 'optionalDependencies',
        scripts: {
            __prepublish: 'prepublish',
            __prepublishOnly: 'prepublishOnly'
        }
    });
}
//# sourceMappingURL=index.js.map