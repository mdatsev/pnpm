"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readFile = readFile;
exports.unlockFile = exports.lockFile = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _lockfile = _interopRequireDefault(require("lockfile"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// locks a file by creating a lock file
const lockFile = function (name, callback) {
  const statDir = name => {
    return new Promise((resolve, reject) => {
      // test to see if the directory exists
      const dirPath = _path.default.dirname(name);

      _fs.default.stat(dirPath, function (err, stats) {
        if (err) {
          return reject(err);
        } else if (!stats.isDirectory()) {
          return resolve(new Error(`${_path.default.dirname(name)} is not a directory`));
        } else {
          return resolve(null);
        }
      });
    });
  };

  const statfile = name => {
    return new Promise((resolve, reject) => {
      // test to see if the directory exists
      _fs.default.stat(name, function (err, stats) {
        if (err) {
          return reject(err);
        } else if (!stats.isFile()) {
          return resolve(new Error(`${_path.default.dirname(name)} is not a file`));
        } else {
          return resolve(null);
        }
      });
    });
  };

  const lockfile = name => {
    return new Promise(resolve => {
      const lockOpts = {
        // time (ms) to wait when checking for stale locks
        wait: 1000,
        // how often (ms) to re-check stale locks
        pollPeriod: 100,
        // locks are considered stale after 5 minutes
        stale: 5 * 60 * 1000,
        // number of times to attempt to create a lock
        retries: 100,
        // time (ms) between tries
        retryWait: 100
      };
      const lockFileName = `${name}.lock`;

      _lockfile.default.lock(lockFileName, lockOpts, () => {
        resolve();
      });
    });
  };

  Promise.resolve().then(() => {
    return statDir(name);
  }).then(() => {
    return statfile(name);
  }).then(() => {
    return lockfile(name);
  }).then(() => {
    callback(null);
  }).catch(err => {
    callback(err);
  });
}; // unlocks file by removing existing lock file


exports.lockFile = lockFile;

const unlockFile = function (name, next) {
  const lockFileName = `${name}.lock`;

  _lockfile.default.unlock(lockFileName, function () {
    return next(null);
  });
};
/**
 *  Reads a local file, which involves
 *  optionally taking a lock
 *  reading the file contents
 *  optionally parsing JSON contents
 * @param {*} name
 * @param {*} options
 * @param {*} callback
 */


exports.unlockFile = unlockFile;

function readFile(name, options = {}, callback = () => {}) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  options.lock = options.lock || false;
  options.parse = options.parse || false;

  const lock = function (options) {
    return new Promise((resolve, reject) => {
      if (!options.lock) {
        return resolve(null);
      }

      lockFile(name, function (err) {
        if (err) {
          return reject(err);
        }

        return resolve(null);
      });
    });
  };

  const read = function () {
    return new Promise((resolve, reject) => {
      _fs.default.readFile(name, 'utf8', function (err, contents) {
        if (err) {
          return reject(err);
        }

        resolve(contents);
      });
    });
  };

  const parseJSON = function (contents) {
    return new Promise((resolve, reject) => {
      if (!options.parse) {
        return resolve(contents);
      }

      try {
        contents = JSON.parse(contents);
        return resolve(contents);
      } catch (err) {
        return reject(err);
      }
    });
  };

  Promise.resolve().then(() => {
    return lock(options);
  }).then(() => {
    return read();
  }).then(content => {
    return parseJSON(content);
  }).then(result => {
    callback(null, result);
  }, err => {
    callback(err);
  });
}